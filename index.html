<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HustleLife: Hood Edition</title>
  <style>
    :root { --bg:#0b0d10; --panel:#12151a; --ink:#e6e9ef; --muted:#9aa4b2; --brand:#6ee7ff; --accent:#a78bfa; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .card{background:var(--panel);border:1px solid #222834;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .row{display:flex;gap:12px;align-items:center}
    .col{display:flex;flex-direction:column;gap:8px}
    .grid{display:grid;gap:12px}
    .grid2{grid-template-columns:1fr 1fr}
    .btn{background:#1f2937;border:1px solid #374151;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn.brand{border-color:#1a2a36;background:#0f1b24;color:#c9f2ff}
    .btn.ok{border-color:#16301f;background:#0e1f14;color:#d6ffe3}
    input,select,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a2f3a;background:#0e1116;color:var(--ink)}
    label{font-size:12px;color:var(--muted)}
    .sectionTitle{font-weight:700;letter-spacing:.3px;color:#cbd5e1}
    .muted{color:var(--muted)}
    .tag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0e1821;border:1px solid #1f2a36;color:#b8deff}
    .players{display:flex;gap:10px;flex-wrap:wrap}
    .pCard{display:flex;flex-direction:column;gap:4px;align-items:center;background:#0e1116;border:1px solid #232833;border-radius:12px;padding:10px;width:120px}
    .pCard img{width:64px;height:64px;border-radius:12px;object-fit:cover;border:1px solid #2a2f3a;background:#090c10}
    .boardWrap{overflow:auto;border:1px solid #232833;border-radius:14px;background:#0a0d12}
    .board{position:relative;display:grid;grid-template-columns:repeat(40, 120px);gap:8px;padding:12px}
    .tile{position:relative;border:1px solid #2b3240;border-radius:12px;padding:8px;background:#0f131a;min-height:120px}
    .tile h4{margin:0 0 6px 0;font-size:12px;color:#cbd5e1}
    .tile p{margin:0;font-size:11px;color:#aab3c0}
    .tile .img{position:absolute;inset:0;border-radius:11px;background:#0a0d12;background-size:cover;background-position:center;opacity:.25}
    .tile .num{position:absolute;top:6px;right:8px;font-size:11px;color:#8aa3b8}
    .tile .action{position:absolute;bottom:8px;left:8px;font-size:10px;color:#89f7d1;background:#06231b;border:1px solid #0c3d31;padding:2px 6px;border-radius:8px}
    .tokens{position:absolute;bottom:6px;right:6px;display:flex;gap:2px;flex-wrap:wrap}
    .token{width:18px;height:18px;border-radius:6px;border:1px solid #2a2f3a;background:#0e1116;overflow:hidden}
    .token img{width:100%;height:100%;object-fit:cover}
    .hud{display:grid;grid-template-columns:1.1fr 1.9fr;gap:12px;margin-top:12px}
    .pane{background:#0e1116;border:1px solid #232833;border-radius:12px;padding:12px}
    .log{max-height:220px;overflow:auto;background:#091017;border:1px solid #162033;border-radius:10px;padding:8px}
    .log p{margin:0 0 6px 0;color:#a8c1d4;font-size:12px}
    .badge{padding:2px 6px;border:1px solid #2d3a31;border-radius:999px;background:#0c1c14;color:#bfead0;font-size:11px}
    .inlineForm{display:flex;gap:8px}
    .small{font-size:12px}
    .danger{color:#ffb3b3}
    .diceWrap{display:flex;align-items:center;gap:12px}
    .dice{width:84px;height:84px;background:#eaeef5;border-radius:16px;border:4px solid #c7d0dc;box-shadow:inset 0 6px 14px rgba(0,0,0,.2), 0 8px 18px rgba(0,0,0,.25);display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);padding:8px;transition:transform .35s ease}
    .dice.roll{transform:rotate(20deg)}
    .pip{width:14px;height:14px;background:#1b2430;border-radius:999px;justify-self:center;align-self:center}
    .pip.hide{visibility:hidden}
    .piles{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .pile{width:140px;height:90px;border-radius:12px;border:2px dashed #28405a;background:#0b1622;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:not-allowed;opacity:.5}
    .pile.active{border-style:solid;background:#0f2133;cursor:pointer;opacity:1}
    .pile h4{margin:0;font-size:13px;color:#cfe7ff}
    .pile .sub{font-size:11px;color:#8fb6db}
    .popup{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:50}
    .popup.show{display:flex}
    .popupCard{max-width:560px;width:90%;background:#0f141b;border:1px solid #28303c;border-radius:14px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,.35)}
    .popupCard h3{margin:0 0 6px 0}
    .popupCard p{margin:0 0 10px 0;color:#b6c2d1}
  </style>
</head>
<body>
<div class="wrap">
  <h1>HustleLife: Hood Edition</h1>
  <p class="muted">A satirical board game navigating life’s challenges. Create/join rooms, play in real time, add images to tiles, and use any image URL as your player token. Sensitive content can be skipped.</p>
  <div id="authScreen" class="card" style="display:none">
    <div class="grid grid2">
      <div class="col">
        <div class="sectionTitle">Your Player</div>
        <label>Display name</label>
        <input id="playerName" placeholder="e.g., Hustler" />
        <label>Avatar image URL (internet or Google Drive public link)</label>
        <input id="playerAvatar" placeholder="https://..." />
        <div class="row">
          <div class="pCard" style="width:auto">
            <img id="avatarPreview" src="" alt="avatar" />
            <div class="small muted">Preview</div>
          </div>
        </div>
        <div class="small muted">Google Drive tip: use <code>https://drive.google.com/uc?export=view&id=FILE_ID</code></div>
      </div>
      <div class="col">
        <div class="sectionTitle">Room</div>
        <label>Room code</label>
        <input id="roomCode" placeholder="e.g., 5‑letter code" maxlength="8" />
        <div class="row">
          <button class="btn brand" id="createRoomBtn">Create Room</button>
          <button class="btn" id="joinRoomBtn">Join Room</button>
        </div>
        <div class="small muted">Creating a room generates a new 5‑letter code.</div>
        <div id="authError" class="small danger"></div>
      </div>
    </div>
  </div>
  <div id="lobbyScreen" class="card" style="display:none">
    <div class="row" style="justify-content:space-between">
      <div class="sectionTitle">Lobby · Room <span id="lobbyCode"></span></div>
      <div class="row">
        <span class="tag">Host: <span id="hostTag">–</span></span>
        <button class="btn" id="leaveRoomBtn">Leave</button>
      </div>
    </div>
    <div class="players" id="playerList"></div>
    <div class="row" style="margin-top:8px;gap:8px">
      <button class="btn ok" id="toggleReadyBtn">Ready</button>
      <button class="btn brand" id="startGameBtn" disabled>Start Game</button>
    </div>
    <div class="pane" style="margin-top:12px">
      <div class="sectionTitle">Host Tools · Tile Images (optional)</div>
      <div class="inlineForm">
        <input id="tileNum" type="number" min="1" max="40" placeholder="Tile # (1-40)" style="width:120px" />
        <input id="tileImgUrl" placeholder="Tile image URL" />
        <button class="btn" id="setTileImgBtn">Set Image</button>
        <button class="btn" id="clearTileImgBtn">Clear</button>
      </div>
      <div class="small muted">Paste any public image URL (supports Google Drive public links).</div>
    </div>
  </div>
  <,U+200B> <div id="gameScreen" class="card" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:flex-start">
      <div>
        <div class="sectionTitle">Room <span id="gameCode"></span></div>
        <div class="small muted">Turn: <span id="turnName">–</span></div>
      </div>
      <div class="row">
        <div class="diceWrap">
          <div id="dice" class="dice" title="Dice">
            <div class="pip" data-pos="1"></div>
            <div class="pip" data-pos="2"></div>
            <div class="pip" data-pos="3"></div>
            <div class="pip" data-pos="4"></div>
            <div class="pip" data-pos="5"></div>
            <div class="pip" data-pos="6"></div>
            <div class="pip" data-pos="7"></div>
            <div class="pip" data-pos="8"></div>
            <div class="pip" data-pos="9"></div>
          </div>
          <button class="btn" id="rollBtn">Roll</button>
          <button class="btn" id="endTurnBtn">End Turn</button>
        </div>
      </div>
    </div>
    <div class="boardWrap" style="margin-top:12px">
      <div class="board" id="board"></div>
    </div>
    <div class="hud">
      <div class="pane">
        <div class="sectionTitle">Players</div>
        <div id="playersHUD" class="players"></div>
        <div class="sectionTitle" style="margin-top:10px">Draw Piles</div>
        <div class="piles">
          <div class="pile" id="pile

-action"><h4>Action Deck</h4><div class="sub" id="pile-action-sub">Inactive</div></div>
          <div class="pile" id="pile-life"><h4>Life Deck</h4><div class="sub" id="pile-life-sub">Inactive</div></div>
          <div class="pile" id="pile-career"><h4>Career Deck</h4><div class="sub" id="pile-career-sub">Inactive</div></div>
        </div>
      </div>
      <div class="pane">
        <div class="sectionTitle">Log</div>
        <div id="log" class="log"></div>
        <div class="row" style="margin-top:8px">
          <input id="chatInput" placeholder="Message" />
          <button class="btn" id="sendChatBtn">Send</button>
        </div>
      </div>
    </div>
  </div>
  <div id="finishScreen" class="card" style="display:none">
    <div class="sectionTitle">Game Over</div>
    <div id="finalScores"></div>
    <div class="row" style="margin-top:10px">
      <button class="btn" id="backToLobbyBtn">Back to Lobby</button>
    </div>
  </div>
</div>
<div id="tilePopup" class="popup">
  <div class="popupCard">
    <div class="small muted" id="popupWho">–</div>
    <h3 id="popupTitle">Tile</h3>
    <p id="popupDesc">Description</p>
    <div class="row" style="justify-content:flex-end">
      <button class="btn" id="popupClose">Close</button>
    </div>
  </div>
</div>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>
<script>
  const firebaseConfig = {
    apiKey: "AIzaSyAEqutXCO5OZD6VU_ohaBxNfh7G8Q6PEy0",
    authDomain: "nomercy-8269a.firebaseapp.com",
    databaseURL: "https://nomercy-8269a-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "nomercy-8269a",
    storageBucket: "nomercy-8269a.firebasestorage.app",
    messagingSenderId: "349047620790",
    appId: "1:349047620790:web:3206ff81cb7f5413d29217",
    measurementId: "G-1WX7CWBFGF"
  };
  (function boot() {
    const app = firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.database();
    const byId = id => document.getElementById(id);
    const screens = { auth: byId('authScreen'), lobby: byId('lobbyScreen'), game: byId('gameScreen'), finish: byId('finishScreen') };
    const show = k => { Object.values(screens).forEach(s => s.style.display = 'none'); screens[k].style.display = 'block'; };
    const setAuthError = msg => byId('authError').textContent = msg;
    const avatarInput = byId('playerAvatar');
    const avatarPreview = byId('avatarPreview');
    avatarInput.addEventListener('input', () => { avatarPreview.src = avatarInput.value || ''; });
    const popup = byId('tilePopup'), popupTitle = byId('popupTitle'), popupDesc = byId('popupDesc'), popupWho = byId('popupWho');
    byId('popupClose').onclick = () => popup.classList.remove('show');
    const diceEl = byId('dice');
    const pips = Array.from(diceEl.querySelectorAll('.pip'));
    const faces = { 1: [5], 2: [1, 9], 3: [1, 5, 9], 4: [1, 3, 7, 9], 5: [1, 3, 5, 7, 9], 6: [1, 3, 4, 6, 7, 9] };
    function renderDie(n) { pips.forEach(p => p.classList.add('hide')); (faces[n] || []).forEach(i => pips[i - 1].classList.remove('hide')); }
    renderDie(1);
    let uid = null, curRoom = null, roomSnap = null;
    const START_HP = 100, BOARD_LEN = 40;
    function defaultTiles() {
      const tiles = [];
      const push = (n, title, description, action, args = {}) => {
        tiles.push({ n, title, description, action, args, imgUrl: '' });
      };
      push(1, 'Start', 'Born in the Hood: Underfunded hospital, nurses say, "Another fighter." Grab your diaper bag and hustle.', 'PAYDAY', { amount: 50 });
      push(2, 'First Steps', 'Toddling around the projects, dodging broken glass. Mom says, "Stay inside, baby."', 'NONE', {});
      push(3, 'Dad Left', 'Your Black dad bounced for cigarettes and never came back. Single-mom grind time.', 'DRAW', { deck: 'life', count: 1 });
      push(4, 'Fried Chicken Feast', 'Auntie’s Sunday dinner: You ate fried chicken till you burst. Soul food hits different.', 'PAYDAY', { amount: 30 });
      push(5, 'Domestic Chaos', 'You witness dad beat your mom before he splits. Cops side with him.', 'STOP', { turns: 1, trauma: 2 });
      push(6, 'Watermelon Summers', 'Block party vibes: You ate lots of watermelon, juice dripping everywhere. Media says it’s a "thing."', 'JUMP', { steps: 2 });
      push(7, 'First Racism Encounter', 'Teacher calls you "aggressive" for raising your hand. Microaggressions 101.', 'DRAW', { deck: 'action', count: 1 });
      push(8, 'Corner Store Run', 'Sent to get milk—store owner follows you like you’re a thief.', 'NONE', { hpLoss: 10, hpThreshold: 50 });
      push(9, 'Block Friends', 'Made your first crew—playing hoops till dark. Bonds for life.', 'FAMILY', { type: 'mentor' });
      push(10, 'End of Innocence', 'Saw your first drive-by. Hood life’s getting real.', 'GOTO', { tile: 11 });
      push(11, 'High School Start', 'Freshman year in overcrowded school. Books outdated, dreams big.', 'CHOOSE_CAREER', { preview: true });
      push(12, 'Police Brutality Intro', 'Stopped for "fitting the description." Roughed up, no charges.', 'JUMP', { steps: -3, trauma: 2 });
      push(13, 'Racism in Class', 'Classmate drops the N-word "as a joke." Teacher laughs it off.', 'DRAW', { deck: 'life', count: 1 });
      push(14, 'Side Hustle Begins', 'Selling candy at school—entrepreneur vibes.', 'PAYDAY', { amount: 100 });
      push(15, 'Path Choice', 'Fork in the road: College dreams or street smarts?', 'CHOOSE_CAREER', { branch: { college: { jump: 5 }, street: { draw: 'action' } } });
      push(16, 'Fried Chicken Cravings', 'Late-night Popeyes run. You ate fried chicken like it’s therapy.', 'NONE', {});
      push(17, 'Family Drama Escalates', 'Mom’s new boyfriend echoes dad’s violence. Cycle continues.', 'FAMILY', { type: 'responsibility', hp: -50 });
      push(18, 'Watermelon Stereotype Mock', 'Friends roast you for loving watermelon. "Black card revoked?" Nah, own it.', 'JUMP', { steps: 1 });
      push(19, 'Activism Spark', 'Join school protest against racism. Eyes opened.', 'DRAW', { deck: 'action', count: 1 });
      push(20, 'Teen Graduation', 'Cap and gown, but half your class dropped out. Bitter-sweet.', 'PAYDAY', { amount: 200 });
      push(21, 'First Real Job', 'Entry-level gig—boss micro-manages ‘cause you’re Black.', 'CHOOSE_CAREER', {});
      push(22, 'Police Brutality Strike', 'Traffic stop gone wrong—you got beaten, viral video optional.', 'GOTO', { tile: 15, trauma: 3 });
      push(23, 'Racism at Work', 'Denied promotion: "Not a culture fit." Code for bias.', 'STOP', { turns: 1, hp: -100 });
      push(24, 'Hustle Payoff', 'Side gig blows up—music or business.', 'PAYDAY', { dice: true, per: 50 });
      push(25, 'Dad Returns? Nah', 'Ghost dad texts for money. Abandonment scars reopen.', 'DRAW', { deck: 'life', count: 1 });
      push(26, 'Fried Chicken Comfort', 'Stress eating: You ate fried chicken to cope with the grind.', 'NONE', {});
      push(27, 'Domestic Echo', 'In your relationship, patterns from childhood emerge—violence creeps in.', 'FAMILY', { type: 'child', trauma: 2 });
      push(28, 'Watermelon Festival', 'Community event: You ate lots of watermelon, reclaiming the stereotype.', 'JUMP', { steps: 3 });
      push(29, 'Systemic Setback', 'Evicted due to gentrification. Hood changing.', 'JUMP', { steps: -5 });
      push(30, 'Grind Milestone', 'Bought your first ride—freedom on wheels.', 'DRAW', { deck: 'action', count: 1 });
      push(31, 'Marriage Milestone', 'Tied the knot—hoping to break cycles.', 'FAMILY', { type: 'spouse', hpPerTurn: 20 });
      push(32, 'Kid Arrives', 'Bundle of joy, but bills stack up.', 'FAMILY', { type: 'child', hp: -100 });
      push(33, 'Family Racism Hit', 'In-laws drop racist vibes at dinner.', 'DRAW', { deck: 'life', count: 1 });
      push(34, 'Police Family Scare', 'Cops harass your teen kid—brutality cycle.', 'STOP', { turns: 1, trauma: 2 });
      push(35, 'Legacy Reflection', 'Teaching kids about dad leaving, violence, stereotypes—breaking chains.', 'REDEEM_TRAUMA', {});
      push(36, 'Big Break', 'Viral success or business boom. Made it?', 'PAYDAY', { multiplier: 2 });
      push(37, 'Final Racism Hurdle', 'Even at the top, "imposter syndrome" from years of bias.', 'DRAW', { deck: 'action', count: 1 });
      push(38, 'Police Flashback', 'Old brutality case payout—justice?', 'PAYDAY', { traumaThreshold: 3, hp: 300 });
      push(39, 'Stereotype Roast', 'Memoir drops: "I Ate Fried Chicken and Watermelon—And Survived the Hood."', 'NONE', {});
      push(40, 'Finish', 'Mansion, community center, or exile—your hood story ends. Tally up.', 'FINISH', {});
      return tiles;
    }
    function defaultDecks() {
      const action = [
        { id: 'a1', title: 'Stand Up', text: 'Confront bias head-on. +50 HP.', effect: { type: 'hp', hp: 50 } },
        { id: 'a2', title: 'Back Down', text: 'Swallow pride to avoid trouble. -20 HP.', effect: { type: 'hp', hp: -20 } },
        { id: 'a3', title: 'Protest Bonus', text: 'Activism pays off. Redeem 1 Trauma Token for +30 HP.', effect: { type: 'tokenToHp', hp: 30 } },
        { id: 'a4', title: 'Community Support', text: 'Neighborhood rallies for you. +40 HP.', effect: { type: 'hp', hp: 40 } },
        { id: 'a5', title: 'Legal Trouble', text: 'Caught in the system. Gain 1 Trauma Token.', effect: { type: 'token', d: 1 } },
      ];
      const life = [
        { id: 'l1', title: 'Mom Works Double Shifts', text: 'Mom’s hustle keeps you afloat. +20 HP, 1 Trauma Token.', effect: { type: 'hpAndToken', hp: 20, trauma: 1 } },
        { id: 'l2', title: 'Forgive Dad', text: 'Emotional closure. +30 HP.', effect: { type: 'hp', hp: 30 } },
        { id: 'l3', title: 'Ignore Dad', text: 'Cut him off. +50 HP.', effect: { type: 'hp', hp: 50 } },
        { id: 'l4', title: 'Therapy', text: 'Discard up to 2 Trauma Tokens, +25 HP each.', effect: { type: 'discardTokensForHp', per: 25, max: 2 } },
        { id: 'l5', title: 'Setback', text: 'Life hits hard. Gain 1 Trauma Token.', effect: { type: 'token', d: 1 } },
      ];
      const career = [
        { id: 'c1', title: 'Rapper', text: 'High risk/reward: Roll D6×30 HP per Payday.', effect: { type: 'careerDice', per: 30 } },
        { id: 'c2', title: 'Entrepreneur', text: 'Steady grind: +50 HP per Payday.', effect: { type: 'career', perTurn: 50 } },
        { id: 'c3', title: 'Activist', text: 'Purpose-driven: +40 HP per Payday, +10 HP per Trauma Token redeemed.', effect: { type: 'career', perTurn: 40, traumaBonus: 10 } },
      ];
      return { action, life, career };
    }
    function shuffle(arr, seed) {
      let x = (seed >>> 0) || 123456789;
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        x ^= x << 13;
        x ^= x >>> 17;
        x ^= x << 5;
        const j = Math.abs(x) % (i + 1);
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    function codeGen() {
      const abc = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
      let s = '';
      for (let i = 0; i < 5; i++) s += abc[Math.floor(Math.random() * abc.length)];
      return s;
    }
    function attachPresence() {
      const pRef = db.ref(`rooms/${curRoom}/players/${uid}/connected`);
      const lastRef = db.ref(`rooms/${curRoom}/players/${uid}/lastSeen`);
      pRef.set(true);
      lastRef.set(Date.now());
      pRef.onDisconnect().set(false);
      lastRef.onDisconnect().set(Date.now());
    }
    function subscribeRoom() {
      db.ref('rooms/' + curRoom).on('value', snap => {
        roomSnap = snap.val();
        if (!roomSnap) { show('auth'); return; }
        render();
      });
    }
    function render() {
      if (!roomSnap) { show('auth'); return; }
      const state = roomSnap.state;
      if (state === 'lobby') { renderLobby(); show('lobby'); }
      else if (state === 'playing') { renderGame(); show('game'); }
      else if (state === 'finished') { renderFinish(); show('finish'); }
      const pop = roomSnap.popup;
      if (pop && pop.ts) {
        popupTitle.textContent = pop.title || 'Tile';
        popupDesc.textContent = pop.description || '';
        popupWho.textContent = `${pop.player || 'Someone'} landed on #${pop.n}`;
        popup.classList.add('show');
      }
    }
    function renderLobby() {
      byId('lobbyCode').textContent = curRoom;
      byId('hostTag').textContent = roomSnap.players?.[roomSnap.hostUid]?.name || '–';
      const list = byId('playerList');
      list.innerHTML = '';
      Object.entries(roomSnap.players || {}).forEach(([id, p]) => {
        const el = document.createElement('div');
        el.className = 'pCard';
        el.innerHTML = `<img src="${p.avatarUrl || ''}" alt="avatar"><div>${p.name || '?'}</div><div class="muted small">${p.ready ? 'Ready ✅' : 'Not ready'}</div>`;
        list.appendChild(el);
      });
      const players = Object.values(roomSnap.players || {});
      const allReady = players.length >= 2 && players.every(p => p.ready);
      byId('startGameBtn').disabled = !((roomSnap.hostUid === uid) && allReady);
    }
    function renderGame() {
      byId('gameCode').textContent = curRoom;
      const turnIdx = roomSnap.currentTurnIndex || 0;
      const order = roomSnap.turnOrder || [];
      const turnUid = order[turnIdx];
      byId('turnName').textContent = roomSnap.players?.[turnUid]?.name || '–';
      const hud = byId('playersHUD');
      hud.innerHTML = '';
      Object.entries(roomSnap.players || {}).forEach(([id, p]) => {
        const card = document.createElement('div');
        card.className = 'pCard';
        card.innerHTML = `<img src="${p.avatarUrl || ''}"><div>${p.name || '?'}</div><div class="badge">HP ${p.hp ?? 0}</div><div class="muted small">Pos ${p.pos ?? 1} · Tok ${p.tokens ?? 0}</div><div class="muted small">${id === turnUid ? '(turn)' : ''}${p.skip > 0 ? '(skip)' : ''}${p.tokens >= 5 ? '(Burnout)' : ''}</div>`;
        hud.appendChild(card);
      });
      const board = byId('board');
      board.innerHTML = '';
      const playersByTile = {};
      Object.entries(roomSnap.players || {}).forEach(([id, p]) => {
        const k = String(p.pos || 1);
        (playersByTile[k] ||= []).push(p);
      });
      for (let i = 1; i <= BOARD_LEN; i++) {
        const t = (roomSnap.tiles || {})[i] || { n: i, title: `Tile ${i}`, description: '', action: 'NONE', args: {}, imgUrl: '' };
        const div = document.createElement('div');
        div.className = 'tile';
        if (t.imgUrl) {
          const im = document.createElement('div');
          im.className = 'img';
          im.style.backgroundImage = `url('${t.imgUrl}')`;
          div.appendChild(im);
        }
        div.innerHTML += `<div class="num">#${i}</div><h4>${t.title || ''}</h4><p>${t.description || ''}</p><div class="action">${t.action}</div>`;
        const tokWrap = document.createElement('div');
        tokWrap.className = 'tokens';
        (playersByTile[String(i)] || []).forEach(p => {
          const tok = document.createElement('div');
          tok.className = 'token';
          tok.title = p.name;
          tok.innerHTML = `<img src="${p.avatarUrl || ''}">`;
          tokWrap.appendChild(tok);
        });
        div.appendChild(tokWrap);
        board.appendChild(div);
      }
      const pending = roomSnap.pendingDraw || null;
      const meTurn = (order[turnIdx] === uid);
      const rolled = !!(roomSnap.turn && roomSnap.turn.rolled);
      function setPileState(kind, active, text) {
        const el = byId(`pile-${kind}`), sub = byId(`pile-${kind}-sub`);
        if (active) { el.classList.add('active'); el.style.cursor = 'pointer'; }
        else { el.classList.remove('active'); el.style.cursor = 'not-allowed'; }
        sub.textContent = text || (active ? 'Click to draw' : 'Inactive');
      }
      setPileState('action', pending && meTurn && pending.uid === uid && pending.deck === 'action', pending?.deck === 'action' ? `Draw ${pending.count}` : 'Inactive');
      setPileState('life', pending && meTurn && pending.uid === uid && pending.deck === 'life', pending?.deck === 'life' ? `Draw ${pending.count}` : 'Inactive');
      setPileState('career', pending && meTurn && pending.uid === uid && pending.deck === 'career', pending?.deck === 'career' ? `Draw ${pending.count}` : 'Inactive');
      if (typeof roomSnap.dice === 'number') { renderDie(roomSnap.dice); }
     _DIALOGUE_ const skip = roomSnap.players?.[uid]?.skip || 0;
      const burnout = (roomSnap.players?.[uid]?.tokens || 0) >= 5;
      byId('rollBtn').disabled = !meTurn || rolled || (pending && pending.uid === uid) || skip > 0 || burnout;
      byId('endTurnBtn').disabled = !meTurn || !rolled || (pending && pending.uid === uid) || skip > 0 || burnout;
    }
    function renderFinish() {
      const box = byId('finalScores');
      const players = Object.values(roomSnap.players || {});
      players.sort((a, b) => (b.hp || 0) - (a.hp || 0) || (a.tokens || 0) - (b.tokens || 0));
      box.innerHTML = '<div class="sectionTitle">Final Standings</div>' + players.map((p, i) => `<p>${i + 1}. ${p.name} — HP ${p.hp} (Trauma Tokens ${p.tokens})</p>`).join('');
    }
    byId('toggleReadyBtn').addEventListener('click', async () => {
      await db.ref(`rooms/${curRoom}/players/${uid}`).update({ ready: !(roomSnap.players?.[uid]?.ready) });
    });
    byId('startGameBtn').addEventListener('click', async () => {
      if (roomSnap.hostUid !== uid) return;
      const players = roomSnap.players || {};
      const updates = {};
      Object.keys(players).forEach(pid => {
        updates[`players/${pid}/hp`] = START_HP;
        updates[`players/${pid}/pos`] = 1;
        updates[`players/${pid}/tokens`] = 0;
        updates[`players/${pid}/ready`] = false;
        updates[`players/${pid}/career`] = null;
        updates[`players/${pid}/skip`] = 0;
      });
      updates['state'] = 'playing';
      updates['currentTurnIndex'] = 0;
      updates['dice'] = null;
      updates['pendingDraw'] = null;
      updates['turn'] = { rolled: false };
      updates['popup'] = null;
      updates['log'] = (roomSnap.log || []).concat({ ts: Date.now(), msg: 'Game started!' });
      await db.ref('rooms/' + curRoom).update(updates);
    });
    byId('leaveRoomBtn').addEventListener('click', async () => {
      if (!curRoom) return;
      await db.ref(`rooms/${curRoom}/players/${uid}`).set(null);
      curRoom = null;
      roomSnap = null;
      show('auth');
    });
    byId('setTileImgBtn').addEventListener('click', async () => {
      if (roomSnap.hostUid !== uid) return alert('Only host can edit tiles.');
      const n = parseInt(byId('tileNum').value || '');
      const url = byId('tileImgUrl').value.trim();
      if (!n || n < 1 || n > BOARD_LEN) return alert('Enter valid tile number.');
      await db.ref(`rooms/${curRoom}/tiles/${n}`).update({ imgUrl: url });
    });
    byId('clearTileImgBtn').addEventListener('click', async () => {
      if (roomSnap.hostUid !== uid) return;
      const n = parseInt(byId('tileNum').value || '');
      if (!n || n < 1 || n > BOARD_LEN) return alert('Enter valid tile number.');
      await db.ref(`rooms/${curRoom}/tiles/${n}`).update({ imgUrl: '' });
    });
    byId('rollBtn').addEventListener('click', async () => {
      if (roomSnap.state !== 'playing') return;
      const order = roomSnap.turnOrder || [];
      const turnUid = order[roomSnap.currentTurnIndex || 0];
      if (turnUid !== uid) return;
      if ((roomSnap.pendingDraw && roomSnap.pendingDraw.uid === uid) || (roomSnap.turn && roomSnap.turn.rolled)) return;
      const meNow = roomSnap.players?.[uid];
      if ((meNow.tokens || 0) >= 5 || (meNow.skip || 0) > 0) return;
      await db.ref(`rooms/${curRoom}/turn`).set({ rolled: true });
      diceEl.classList.add('roll');
      const roll = 1 + Math.floor(Math.random() * 6);
      setTimeout(async () => {
        diceEl.classList.remove('roll');
        renderDie(roll);
        await db.ref(`rooms/${curRoom}`).update({ dice: roll });
        const newPos = Math.min(BOARD_LEN, (meNow.pos || 1) + roll);
        await db.ref(`rooms/${curRoom}/players/${uid}`).update({ pos: newPos });
        await applyTile(newPos);
      }, 300);
    });
    byId('endTurnBtn').addEventListener('click', async () => {
      if (roomSnap.state !== 'playing') return;
      const order = roomSnap.turnOrder || [];
      if (order[roomSnap.currentTurnIndex || 0] !== uid) return;
      if (roomSnap.pendingDraw && roomSnap.pendingDraw.uid === uid) return;
      const meNow = roomSnap.players?.[uid];
      if ((meNow.tokens || 0) >= 5 || (meNow.skip || 0) > 0) {
        await db.ref(`rooms/${curRoom}/players/${uid}`).update({ skip: Math.max(0, (meNow.skip || 0) - 1) });
        await logMsg(`${meNow.name} skips turn due to ${(meNow.tokens || 0) >= 5 ? 'Burnout' : 'Stop'}.`);
      }
      await nextTurn();
    });
    byId('pile-action').addEventListener('click', () => handlePile('action'));
    byId('pile-life').addEventListener('click', () => handlePile('life'));
    byId('pile-career').addEventListener('click', () => handlePile('career'));
    async function handlePile(deck) {
      const pending = roomSnap.pendingDraw;
      const order = roomSnap.turnOrder || [];
      const myTurn = order[roomSnap.currentTurnIndex || 0] === uid;
      if (!pending || !myTurn || pending.uid !== uid || pending.deck !== deck) return;
      await drawCard(deck, 1, true);
      const left = (pending.count || 1) - 1;
      if (left > 0) {
        await db.ref('rooms/' + curRoom + '/pendingDraw').update({ count: left });
      } else {
        await db.ref('rooms/' + curRoom).update({ pendingDraw: null });
      }
    }
    async function logMsg(msg) {
      const arr = (roomSnap.log || []);
      arr.push({ ts: Date.now(), msg });
      await db.ref('rooms/' + curRoom).update({ log: arr.slice(-300) });
    }
    async function nextTurn() {
      const order = roomSnap.turnOrder || [];
      let idx = (roomSnap.currentTurnIndex || 0) + 1;
      if (idx >= order.length) idx = 0;
      await db.ref('rooms/' + curRoom).update({
        currentTurnIndex: idx,
        dice: null,
        popup: null,
        turn: { rolled: false },
        pendingDraw: null
      });
    }
    async function showPopupForAll(t, playerName) {
      await db.ref('rooms/' + curRoom + '/popup').set({
        n: t.n,
        title: t.title,
        description: t.description,
        player: playerName,
        ts: Date.now()
      });
    }
    async function applyTile(pos) {
      const t = (roomSnap.tiles || {})[pos];
      if (!t) return;
      const playerName = roomSnap.players[uid].name;
      await showPopupForAll(t, playerName);
      await logMsg(`${playerName} lands on #${pos}: ${t.title}`);
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      if (t.args.trauma) {
        await meRef.update({ tokens: (meNow.tokens || 0) + t.args.trauma });
        await logMsg(`${playerName} gains ${t.args.trauma} Trauma Token(s).`);
      }
      if ((meNow.tokens || 0) + (t.args.trauma || 0) >= 5) {
        await meRef.update({ skip: (meNow.skip || 0) + 1 });
        await logMsg(`${playerName} hits Burnout, skips next turn.`);
      }
      switch (t.action) {
        case 'NONE':
          if (t.args.hpLoss && t.args.hpThreshold && (meNow.hp || 0) < t.args.hpThreshold) {
            await meRef.update({ hp: (meNow.hp || 0) - t.args.hpLoss });
            await logMsg(`${playerName} loses ${t.args.hpLoss} HP (can't afford it).`);
          }
          break;
        case 'PAYDAY':
          await applyPayday(t.args || {});
          break;
        case 'JUMP':
          await moveBy(t.args?.steps || 0);
          break;
        case 'GOTO':
          await moveTo(t.args?.tile || pos);
          break;
        case 'STOP':
          await applyStop(t.args?.turns || 1);
          break;
        case 'DRAW':
          const count = Math.max(1, t.args?.count || 1);
          const deck = (t.args?.deck || 'action');
          await db.ref('rooms/' + curRoom + '/pendingDraw').set({ uid, deck, count });
          break;
        case 'FAMILY':
          await applyFamily(t.args || {});
          break;
        case 'CHOOSE_CAREER':
          await chooseCareer(t.args || {});
          break;
        case 'REDEEM_TRAUMA':
          await redeemTrauma();
          break;
        case 'FINISH':
          await finishGame();
          return;
      }
    }
    async function applyPayday(args) {
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      let delta = 0;
      if (args.amount) delta += args.amount;
      if (args.multiplier) delta += (meNow.hp || 0) * (args.multiplier - 1);
      if (args.dice) delta += (1 + Math.floor(Math.random() * 6)) * (args.per || 0);
      if (args.traumaThreshold && (meNow.tokens || 0) > args.traumaThreshold) delta += (args.hp || 0);
      if (meNow.career?.perTurn) delta += meNow.career.perTurn;
      if (meNow.career?.dice) delta += (1 + Math.floor(Math.random() * 6)) * (meNow.career.per || 30);
      if (meNow.hpPerTurn) delta += meNow.hpPerTurn;
      await meRef.update({ hp: (meNow.hp || 0) + delta });
      await logMsg(`${meNow.name} Payday: ${delta >= 0 ? '+' : ''}${delta} HP`);
    }
    async function moveBy(steps) {
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const newPos = Math.max(1, Math.min(BOARD_LEN, (meNow.pos || 1) + steps));
      await meRef.update({ pos: newPos });
      await logMsg(`${meNow.name} ${steps >= 0 ? 'jumps' : 'falls'} ${steps} to ${newPos}`);
      await applyTile(newPos);
    }
    async function moveTo(tile) {
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const newPos = Math.max(1, Math.min(BOARD_LEN, tile));
      await meRef.update({ pos: newPos });
      await logMsg(`${meNow.name} goes to tile ${newPos}`);
      await applyTile(newPos);
    }
    async function applyStop(turns) {
      await logMsg(`${roomSnap.players[uid].name} pauses for ${turns} turn(s).`);
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const skip = Math.max(0, (meNow.skip || 0) + (turns || 1));
      await meRef.update({ skip });
    }
    async function drawCard(deck, count) {
      for (let i = 0; i < count; i++) await drawOne(deck);
    }
    async function drawOne(deck) {
      const idsRef = db.ref(`rooms/${curRoom}/decks/ids/${deck}`);
      const discRef = db.ref(`rooms/${curRoom}/decks/discard/${deck}`);
      let ids = (await idsRef.get()).val() || [];
      if (ids.length === 0) {
        const disc = (await discRef.get()).val() || [];
        const seed = roomSnap.seed || 12345;
        ids = shuffle(disc, seed + Math.floor(Math.random() * 999));
        await discRef.set([]);
      }
      const cardId = ids.shift();
      await idsRef.set(ids);
      const discArr = ((roomSnap.decks?.discard?.[deck]) || []).concat(cardId);
      await discRef.set(discArr);
      const card = findCard(deck, cardId);
      await logMsg(`${roomSnap.players[uid].name} draws from ${deck}: ${card.title}`);
      await applyCardEffect(card.effect || {});
    }
    function findCard(deck, id) {
      const d = defaultDecks();
      return (d[deck] || []).find(c => c.id === id) || { id, title: 'Unknown', text: '', effect: {} };
    }
    async function applyCardEffect(effect) {
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      switch (effect.type) {
        case 'hp':
          await meRef.update({ hp: (meNow.hp || 0) + (effect.hp || 0) });
          break;
        case 'token':
          await meRef.update({ tokens: (meNow.tokens || 0) + (effect.d || 0) });
          break;
        case 'hpAndToken':
          await meRef.update({ hp: (meNow.hp || 0) + (effect.hp || 0), tokens: (meNow.tokens || 0) + (effect.trauma || 0) });
          if ((meNow.tokens || 0) + (effect.trauma || 0) >= 5) {
            await meRef.update({ skip: (meNow.skip || 0) + 1 });
            await logMsg(`${meNow.name} hits Burnout, skips next turn.`);
          }
          break;
        case 'discardTokensForHp':
          const take = Math.min(effect.max || 0, meNow.tokens || 0);
          const gain = (effect.per || 0) * take;
          await meRef.update({ tokens: (meNow.tokens || 0) - take, hp: (meNow.hp || 0) + gain });
          break;
        case 'tokenToHp':
          if ((meNow.tokens || 0) > 0) {
            await meRef.update({ tokens: (meNow.tokens || 0) - 1, hp: (meNow.hp || 0) + (effect.hp || 0) });
          }
          break;
        case 'career':
          const career = { perTurn: effect.perTurn || 0, traumaBonus: effect.traumaBonus || 0 };
          await meRef.update({ career });
          break;
        case 'careerDice':
          const careerDice = { dice: true, per: effect.per || 30 };
          await meRef.update({ career: careerDice });
          break;
      }
    }
    async function applyFamily(args) {
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      switch (args.type) {
        case 'mentor':
          await meRef.update({ hp: (meNow.hp || 0) + 40 });
 Dementia

          await logMsg('Mentor boosts +40 HP');
          break;
        case 'responsibility':
          await meRef.update({ hp: (meNow.hp || 0) + (args.hp || 0) });
          await logMsg('Family responsibility costs ' + (-args.hp || 0) + ' HP');
          break;
        case 'spouse':
          await meRef.update({ hpPerTurn: (meNow.hpPerTurn || 0) + (args.hpPerTurn || 0) });
          await logMsg('Spouse adds +' + (args.hpPerTurn || 0) + ' HP per turn');
          break;
        case 'child':
          await meRef.update({ hp: (meNow.hp || 0) + (args.hp || 0), children: (meNow.children || 0) + 1 });
          await logMsg('New child costs ' + (-args.hp || 0) + ' HP');
          break;
      }
      if (args.trauma) {
        await meRef.update({ tokens: (meNow.tokens || 0) + args.trauma });
        await logMsg(`${meNow.name} gains ${args.trauma} Trauma Token(s).`);
      }
    }
    async function chooseCareer(args) {
      const meNow = roomSnap.players[uid];
      if (args.preview) return;
      if (args.branch) {
        const choice = Math.random() < 0.5 ? 'college' : 'street';
        if (choice === 'college') {
          await moveBy(args.branch.college.jump);
          await logMsg(`${meNow.name} chooses College path, jumps +${args.branch.college.jump}.`);
        } else {
          await db.ref('rooms/' + curRoom + '/pendingDraw').set({ uid, deck: 'action', count: 1 });
          await logMsg(`${meNow.name} chooses Street Hustle, draws Action card.`);
        }
        return;
      }
      const choices = defaultDecks().career;
      const pick = choices[Math.floor(Math.random() * choices.length)];
      await applyCardEffect(pick.effect);
      await logMsg(`${meNow.name} chooses a career: ${pick.title}`);
    }
    async function redeemTrauma() {
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const tokens = meNow.tokens || 0;
      const multiplier = meNow.career?.traumaBonus ? 1 + (meNow.career.traumaBonus / 100) : 1;
      const hpGain = tokens * 50 * multiplier;
      await meRef.update({ tokens: 0, hp: (meNow.hp || 0) + hpGain });
      await logMsg(`${meNow.name} redeems ${tokens} Trauma Tokens for +${hpGain} HP`);
    }
    async function finishGame() {
      await db.ref('rooms/' + curRoom).update({ state: 'finished', log: (roomSnap.log || []).concat({ ts: Date.now(), msg: 'Finished! Tally scores.' }) });
    }
    byId('sendChatBtn').addEventListener('click', async () => {
      if (!curRoom) return;
      const msg = byId('chatInput').value.trim();
      if (!msg) return;
      await logMsg(`${roomSnap.players?.[uid]?.name || 'Player'}: ${msg}`);
      byId('chatInput').value = '';
    });
    byId('backToLobbyBtn').addEventListener('click', async () => {
      await db.ref('rooms/' + curRoom).update({ state: 'lobby' });
    });
    function seed() {
      return Math.floor(Math.random() * 1e9);
    }
    function makeDeckIds(s) {
      const d = defaultDecks();
      return {
        action: shuffle(d.action.map(c => c.id), s + 11),
        life: shuffle(d.life.map(c => c.id), s + 17),
        career: shuffle(d.career.map(c => c.id), s + 23)
      };
    }
    async function createRoom() {
      const name = byId('playerName').value.trim();
      const avatarUrl = byId('playerAvatar').value.trim();
      if (!name) return setAuthError('Please enter a display name.');
      const code = codeGen();
      const s = seed();
      const deckIds = makeDeckIds(s);
      const tiles = defaultTiles();
      const roomRef = db.ref('rooms/' + code);
      const user = {
        name,
        avatarUrl: avatarUrl || '',
        hp: START_HP,
        pos: 1,
        tokens: 0,
        ready: false,
        connected: true,
        lastSeen: Date.now(),
        career: null,
        skip: 0,
        hpPerTurn: 0,
        children: 0
      };
      await roomRef.set({
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        state: 'lobby',
        hostUid: uid,
        seed: s,
        decks: { ids: deckIds, discard: { action: [], life: [], career: [] } },
        tiles: Object.fromEntries(tiles.map(t => [t.n, t])),
        players: { [uid]: user },
        turnOrder: [uid],
        currentTurnIndex: 0,
        dice: null,
        pendingDraw: null,
        turn: { rolled: false },
        popup: null,
        log: [{ ts: Date.now(), msg: `${name} created room ${code}` }]
      });
      curRoom = code;
      attachPresence();
      subscribeRoom();
    }
    async function joinRoom() {
      const name = byId('playerName').value.trim();
      const avatarUrl = byId('playerAvatar').value.trim();
      const code = byId('roomCode').value.trim().toUpperCase();
      if (!name) return setAuthError('Please enter a display name.');
      if (!code) return setAuthError('Please enter a room code.');
      const roomRef = db.ref('rooms/' + code);
      const snap = await roomRef.get();
      if (!snap.exists()) return setAuthError('Room not found.');
      const userRef = roomRef.child('players/' + uid);
      const user = {
        name,
        avatarUrl: avatarUrl || '',
        hp: START_HP,
        pos: 1,
        tokens: 0,
        ready: false,
        connected: true,
        lastSeen: Date.now(),
        career: null,
        skip: 0,
        hpPerTurn: 0,
        children: 0
      };
      await userRef.update(user);
      await roomRef.child('turnOrder').transaction(arr => {
        if (!arr) return [uid];
        if (!arr.includes(uid)) arr.push(uid);
        return arr;
      });
      curRoom = code;
      attachPresence();
      subscribeRoom();
    }
    byId('createRoomBtn').addEventListener('click', createRoom);
    byId('joinRoomBtn').addEventListener('click', joinRoom);
    auth.onAuthStateChanged(async user => {
      if (user) { uid = user.uid; show('auth'); }
      else { await auth.signInAnonymously(); }
    });
  })();
</script>
</body>
</html>
