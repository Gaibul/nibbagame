<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HustleLife — Multiplayer (Firebase Rooms)</title>
  <style>
    :root { --bg:#0b0d10; --panel:#12151a; --ink:#e6e9ef; --muted:#9aa4b2; --brand:#6ee7ff; --accent:#a78bfa; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .card{background:var(--panel);border:1px solid #222834;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .row{display:flex;gap:12px;align-items:center}
    .col{display:flex;flex-direction:column;gap:8px}
    .grid{display:grid;gap:12px}
    .grid2{grid-template-columns:1fr 1fr}
    .btn{background:#1f2937;border:1px solid #374151;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn.brand{border-color:#1a2a36;background:#0f1b24;color:#c9f2ff}
    .btn.ok{border-color:#16301f;background:#0e1f14;color:#d6ffe3}
    .btn.warn{border-color:#3a2b10;background:#1f1608;color:#ffe6b8}
    input,select,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a2f3a;background:#0e1116;color:var(--ink)}
    label{font-size:12px;color:var(--muted)}
    .sectionTitle{font-weight:700;letter-spacing:.3px;color:#cbd5e1}
    .muted{color:var(--muted)}
    .tag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0e1821;border:1px solid #1f2a36;color:#b8deff}
    .players{display:flex;gap:10px;flex-wrap:wrap}
    .pCard{display:flex;flex-direction:column;gap:4px;align-items:center;background:#0e1116;border:1px solid #232833;border-radius:12px;padding:10px;width:120px}
    .pCard img{width:64px;height:64px;border-radius:12px;object-fit:cover;border:1px solid #2a2f3a;background:#090c10}
    .boardWrap{overflow:auto;border:1px solid #232833;border-radius:14px;background:#0a0d12}
    .board{position:relative;display:grid;grid-template-columns:repeat(40, 120px);gap:8px;padding:12px}
    .tile{position:relative;border:1px solid #2b3240;border-radius:12px;padding:8px;background:#0f131a;min-height:120px}
    .tile h4{margin:0 0 6px 0;font-size:12px;color:#cbd5e1}
    .tile p{margin:0;font-size:11px;color:#aab3c0}
    .tile .img{position:absolute;inset:0;border-radius:11px;background:#0a0d12;background-size:cover;background-position:center;opacity:.25}
    .tile .num{position:absolute;top:6px;right:8px;font-size:11px;color:#8aa3b8}
    .tile .action{position:absolute;bottom:8px;left:8px;font-size:10px;color:#89f7d1;background:#06231b;border:1px solid #0c3d31;padding:2px 6px;border-radius:8px}
    .tokens{position:absolute;bottom:6px;right:6px;display:flex;gap:2px;flex-wrap:wrap}
    .token{width:18px;height:18px;border-radius:6px;border:1px solid #2a2f3a;background:#0e1116;overflow:hidden}
    .token img{width:100%;height:100%;object-fit:cover}
    .hud{display:grid;grid-template-columns:1fr 2fr;gap:12px;margin-top:12px}
    .pane{background:#0e1116;border:1px solid #232833;border-radius:12px;padding:12px}
    .log{max-height:200px;overflow:auto;background:#091017;border:1px solid #162033;border-radius:10px;padding:8px}
    .log p{margin:0 0 6px 0;color:#a8c1d4;font-size:12px}
    .badge{padding:2px 6px;border:1px solid #2d3a31;border-radius:999px;background:#0c1c14;color:#bfead0;font-size:11px}
    .inlineForm{display:flex;gap:8px}
    .small{font-size:12px}
    .danger{color:#ffb3b3}
  </style>
</head>
<body>
<div class="wrap">
  <h1>HustleLife — Multiplayer (Firebase Rooms)</h1>
  <p class="muted">Create/join rooms, play in real time, add images to tiles, and use any image URL as your player token.</p>

  <!-- Auth / Join -->
  <div id="authScreen" class="card" style="display:none">
    <div class="grid grid2">
      <div class="col">
        <div class="sectionTitle">Your Player</div>
        <label>Display name</label>
        <input id="playerName" placeholder="e.g., Gaibul" />
        <label>Avatar image URL (internet or Google Drive public link)</label>
        <input id="playerAvatar" placeholder="https://..." />
        <div class="row">
          <div class="pCard" style="width:auto">
            <img id="avatarPreview" src="" alt="avatar" />
            <div class="small muted">Preview</div>
          </div>
        </div>
        <div class="small muted">Google Drive tip: use <code>https://drive.google.com/uc?export=view&id=FILE_ID</code></div>
      </div>
      <div class="col">
        <div class="sectionTitle">Room</div>
        <label>Room code</label>
        <input id="roomCode" placeholder="e.g., 5‑letter code" maxlength="8" />
        <div class="row">
          <button class="btn brand" id="createRoomBtn">Create Room</button>
          <button class="btn" id="joinRoomBtn">Join Room</button>
        </div>
        <div class="small muted">Creating a room generates a new 5‑letter code.</div>
        <div id="authError" class="small danger"></div>
      </div>
    </div>
  </div>

  <!-- Lobby -->
  <div id="lobbyScreen" class="card" style="display:none">
    <div class="row" style="justify-content:space-between">
      <div class="sectionTitle">Lobby · Room <span id="lobbyCode"></span></div>
      <div class="row">
        <span class="tag">Host: <span id="hostTag">–</span></span>
        <button class="btn" id="leaveRoomBtn">Leave</button>
      </div>
    </div>
    <div class="players" id="playerList"></div>
    <div class="row" style="margin-top:8px;gap:8px">
      <button class="btn ok" id="toggleReadyBtn">Ready</button>
      <button class="btn brand" id="startGameBtn" disabled>Start Game</button>
    </div>

    <div class="pane" style="margin-top:12px">
      <div class="sectionTitle">Host Tools · Tile Images (optional)</div>
      <div class="inlineForm">
        <input id="tileNum" type="number" min="1" max="40" placeholder="Tile # (1-40)" style="width:120px" />
        <input id="tileImgUrl" placeholder="Tile image URL" />
        <button class="btn" id="setTileImgBtn">Set Image</button>
        <button class="btn" id="clearTileImgBtn">Clear</button>
      </div>
      <div class="small muted">Paste any public image URL (supports Google Drive public links).</div>
    </div>
  </div>

  <!-- Game -->
  <div id="gameScreen" class="card" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:flex-start">
      <div>
        <div class="sectionTitle">Room <span id="gameCode"></span></div>
        <div class="small muted">Turn: <span id="turnName">–</span> · Roll: <span id="lastRoll">–</span></div>
      </div>
      <div class="row">
        <button class="btn" id="rollBtn">Roll</button>
        <button class="btn" id="drawBtn">Draw</button>
        <button class="btn" id="endTurnBtn">End Turn</button>
      </div>
    </div>

    <div class="boardWrap" style="margin-top:12px">
      <div class="board" id="board"></div>
    </div>

    <div class="hud">
      <div class="pane">
        <div class="sectionTitle">Players</div>
        <div id="playersHUD" class="players"></div>
      </div>
      <div class="pane">
        <div class="sectionTitle">Log</div>
        <div id="log" class="log"></div>
        <div class="row" style="margin-top:8px">
          <input id="chatInput" placeholder="Message" />
          <button class="btn" id="sendChatBtn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Finish -->
  <div id="finishScreen" class="card" style="display:none">
    <div class="sectionTitle">Game Over</div>
    <div id="finalScores"></div>
    <div class="row" style="margin-top:10px">
      <button class="btn" id="backToLobbyBtn">Back to Lobby</button>
    </div>
  </div>
</div>

<!-- Firebase compat (works from file://) -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

<script>
  // ---- Your Firebase config (as provided) ----
  const firebaseConfig = {
    apiKey: "AIzaSyAEqutXCO5OZD6VU_ohaBxNfh7G8Q6PEy0",
    authDomain: "nomercy-8269a.firebaseapp.com",
    databaseURL: "https://nomercy-8269a-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "nomercy-8269a",
    storageBucket: "nomercy-8269a.firebasestorage.app",
    messagingSenderId: "349047620790",
    appId: "1:349047620790:web:3206ff81cb7f5413d29217",
    measurementId: "G-1WX7CWBFGF"
  };

  // ===== Boot =====
  (function boot(){
    const app = firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db   = firebase.database();

    // ===== UI helpers =====
    const byId = id => document.getElementById(id);
    const screens = { auth: byId('authScreen'), lobby: byId('lobbyScreen'), game: byId('gameScreen'), finish: byId('finishScreen') };
    const show = k => { Object.values(screens).forEach(s=>s.style.display='none'); screens[k].style.display='block'; };

    const avatarInput = byId('playerAvatar');
    const avatarPreview = byId('avatarPreview');
    avatarInput.addEventListener('input', () => { avatarPreview.src = avatarInput.value || '' });

    // ===== State =====
    let uid = null, curRoom = null, roomSnap = null;
    const START_HP = 100, BOARD_LEN = 40;

    // ===== Model =====
    function defaultTiles(){
      const t=[]; const push=(n,title,description,action,args={})=>t.push({n,title,description,action,args,imgUrl:''});
      push(1,'Start','A new chapter begins. Steady breath, clear goals.','PAYDAY',{amount:50});
      push(2,'First Steps','You find your rhythm in a new neighborhood.','NONE');
      push(3,'Mentor Found','A mentor shares time and wisdom.','DRAW',{deck:'life',count:1});
      push(4,'Community Potluck','You help organize a local event.','PAYDAY',{amount:30});
      push(5,'Tough Lesson','A setback teaches resilience.','STOP',{turns:1});
      push(6,'Library Card','Resources open new ideas.','JUMP',{steps:2});
      push(7,'After‑school Project','You step up for a team task.','DRAW',{deck:'action',count:1});
      push(8,'Corner Shop','Budgeting day: small choices add up.','NONE');
      push(9,'New Friends','Support network grows.','FAMILY',{type:'mentor'});
      push(10,'Milestone','Time to level up.','GOTO',{tile:11});
      push(11,'High School','Overcrowded classrooms, determined spirit.','DRAW',{deck:'life',count:1});
      push(12,'Wrong Bus','Late to class; adapt fast.','JUMP',{steps:-1});
      push(13,'Talent Show','Spotlight moment boosts confidence.','PAYDAY',{amount:60});
      push(14,'Study Group','Peers make the load lighter.','DRAW',{deck:'action',count:1});
      push(15,'Path Choice','College program or vocational hustle?','CHOOSE_CAREER');
      push(16,'Part‑time Gig','Time management trial by fire.','PAYDAY',{amount:100});
      push(17,'Family Duties','You help at home, time gets tight.','FAMILY',{type:'responsibility'});
      push(18,'Volunteering','Service builds perspective.','JUMP',{steps:1});
      push(19,'Presentation Day','You lead the team and learn a ton.','DRAW',{deck:'life',count:1});
      push(20,'Graduation','Caps up, eyes forward.','PAYDAY',{amount:200});
      push(21,'First Job','Onboarding jitters, steady progress.','CHOOSE_CAREER');
      push(22,'Detour','Paperwork snafu reroutes you.','GOTO',{tile:15});
      push(23,'Stretch Project','You take on more responsibility.','STOP',{turns:1});
      push(24,'Side Hustle','Your idea starts to click.','PAYDAY',{dice:true,per:50});
      push(25,'Old Wounds','You practice letting go to move on.','DRAW',{deck:'life',count:1});
      push(26,'Comfort Food Night','Rest, recharge, reconnect.','NONE');
      push(27,'Relationship Check‑in','You invest time in the people who matter.','FAMILY',{type:'bond'});
      push(28,'Street Fair','Neighborhood energy lifts you.','JUMP',{steps:3});
      push(29,'Housing Shuffle','Rising rents push a move.','JUMP',{steps:-5});
      push(30,'First Wheels','Mobility expands options.','DRAW',{deck:'action',count:1});
      push(31,'Commitment','Partners align goals and budgets.','FAMILY',{type:'partner'});
      push(32,'New Arrival','Joy grows—and so do expenses.','FAMILY',{type:'child'});
      push(33,'Hard Conversation','You tackle bias and boundaries with care.','DRAW',{deck:'life',count:1});
      push(34,'Safety Workshop','Community learns, supports, plans.','STOP',{turns:1});
      push(35,'Pass It On','You mentor someone starting out.','PAYDAY',{amount:120});
      push(36,'Big Break','Momentum is real.','PAYDAY',{multiplier:2});
      push(37,'Doubt Creeps','Imposter whispers—facts push back.','DRAW',{deck:'action',count:1});
      push(38,'Old Case Closed','Lingering issue resolved; sigh of relief.','PAYDAY',{amount:150});
      push(39,'Tell Your Story','Share the journey; others learn.','NONE');
      push(40,'Finish','Tally HP; highest wins. Tie: fewest challenge tokens.','FINISH');
      return Array.from({length:BOARD_LEN},(_,i)=>t[i]||{n:i+1,title:`Tile ${i+1}`,description:'Customizable.',action:'NONE',args:{},imgUrl:''});
    }

    function defaultDecks(){
      const action = [
        {id:'a1', title:'Push Through', text:'Convert 1 challenge token to +30 HP.', effect:{type:'tokenToHp', hp:30}},
        {id:'a2', title:'Small Win', text:'+50 HP from a clever shortcut.', effect:{type:'hp', hp:50}},
        {id:'a3', title:'Unexpected Bill', text:'-40 HP. Ouch.', effect:{type:'hp', hp:-40}},
      ];
      const life = [
        {id:'l1', title:'Scholarship', text:'+100 HP. Use wisely.', effect:{type:'hp', hp:100}},
        {id:'l2', title:'Setback', text:'Gain 1 challenge token.', effect:{type:'token', d:1}},
        {id:'l3', title:'Therapy Session', text:'Discard up to 2 tokens, +20 HP each.', effect:{type:'discardTokensForHp', per:20, max:2}},
      ];
      const career = [
        {id:'c1', title:'Apprentice', text:'+40 HP per Payday turn.', effect:{type:'career', perTurn:40}},
        {id:'c2', title:'Analyst', text:'+60 HP per Payday turn.', effect:{type:'career', perTurn:60}},
        {id:'c3', title:'Creator', text:'Roll‑based income (D6×20) on Payday.', effect:{type:'careerDice', per:20}},
      ];
      return { action, life, career };
    }

    function shuffle(arr, seed){ let x=(seed>>>0)||123456789; const a=arr.slice(); for(let i=a.length-1;i>0;i--){ x^=x<<13; x^=x>>>17; x^=x<<5; const j=Math.abs(x)%(i+1); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    function codeGen(){ const abc='ABCDEFGHJKMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<5;i++) s+=abc[Math.floor(Math.random()*abc.length)]; return s; }
    function setAuthError(msg){ byId('authError').textContent = msg; }

    // ===== Presence =====
    function attachPresence(){
      const pRef = db.ref(`rooms/${curRoom}/players/${uid}/connected`);
      const lastRef = db.ref(`rooms/${curRoom}/players/${uid}/lastSeen`);
      pRef.set(true); lastRef.set(Date.now());
      pRef.onDisconnect().set(false);
      lastRef.onDisconnect().set(Date.now());
    }

    function subscribeRoom(){
      db.ref('rooms/'+curRoom).on('value', snap => {
        roomSnap = snap.val();
        if(!roomSnap){ show('auth'); return; }
        render();
      });
    }

    // ===== Renderers =====
    function render(){
      if(!roomSnap){ show('auth'); return; }
      const state = roomSnap.state;
      if(state==='lobby'){ renderLobby(); show('lobby'); }
      else if(state==='playing'){ renderGame(); show('game'); }
      else if(state==='finished'){ renderFinish(); show('finish'); }
    }

    function renderLobby(){
      byId('lobbyCode').textContent = curRoom;
      byId('hostTag').textContent = roomSnap.players?.[roomSnap.hostUid]?.name || '–';
      const list = byId('playerList'); list.innerHTML='';
      Object.entries(roomSnap.players||{}).forEach(([id,p])=>{
        const el = document.createElement('div'); el.className='pCard';
        el.innerHTML = `<img src="${p.avatarUrl||''}" alt="avatar"><div>${p.name||'?'}</div><div class="muted small">${p.ready?'Ready ✅':'Not ready'}</div>`;
        list.appendChild(el);
      });
      const players = Object.values(roomSnap.players||{});
      const allReady = players.length>=2 && players.every(p=>p.ready);
      byId('startGameBtn').disabled = !((roomSnap.hostUid===uid) && allReady);
    }

    function renderGame(){
      byId('gameCode').textContent = curRoom;
      const turnIdx = roomSnap.currentTurnIndex||0;
      const order = roomSnap.turnOrder||[];
      const turnUid = order[turnIdx];
      byId('turnName').textContent = roomSnap.players?.[turnUid]?.name || '–';
      byId('lastRoll').textContent = roomSnap.dice==null ? '–' : roomSnap.dice;

      const hud = byId('playersHUD'); hud.innerHTML='';
      Object.entries(roomSnap.players||{}).forEach(([id,p])=>{
        const card = document.createElement('div'); card.className='pCard';
        card.innerHTML = `<img src="${p.avatarUrl||''}"><div>${p.name||'?'}</div><div class="badge">HP ${p.hp ?? 0}</div><div class="muted small">Pos ${p.pos ?? 1} · Tok ${p.tokens ?? 0}</div><div class="muted small">${id===turnUid?'(turn)':''}</div>`;
        hud.appendChild(card);
      });

      const board = byId('board'); board.innerHTML='';
      const playersByTile = {};
      Object.entries(roomSnap.players||{}).forEach(([id,p])=>{
        const k=String(p.pos||1); (playersByTile[k] ||= []).push(p);
      });

      for(let i=1;i<=BOARD_LEN;i++){
        const t = (roomSnap.tiles||{})[i] || {n:i,title:`Tile ${i}`,description:'',action:'NONE',args:{},imgUrl:''};
        const div = document.createElement('div'); div.className='tile';
        if(t.imgUrl){ const im=document.createElement('div'); im.className='img'; im.style.backgroundImage = `url('${t.imgUrl}')`; div.appendChild(im); }
        div.innerHTML += `<div class="num">#${i}</div><h4>${t.title||''}</h4><p>${t.description||''}</p><div class="action">${t.action}</div>`;
        const tokWrap = document.createElement('div'); tokWrap.className='tokens';
        (playersByTile[String(i)]||[]).forEach(p=>{
          const tok=document.createElement('div'); tok.className='token'; tok.title=p.name;
          tok.innerHTML=`<img src="${p.avatarUrl||''}">`; tokWrap.appendChild(tok);
        });
        div.appendChild(tokWrap); board.appendChild(div);
      }

      const log = byId('log'); log.innerHTML='';
      (roomSnap.log||[]).slice(-200).forEach(l=>{
        const p=document.createElement('p'); const d=new Date(l.ts||Date.now());
        p.textContent = `[${d.toLocaleTimeString()}] ${l.msg}`; log.appendChild(p);
      });

      const myTurn = order[turnIdx]===uid;
      byId('rollBtn').disabled = !myTurn;
      byId('drawBtn').disabled = !myTurn;
      byId('endTurnBtn').disabled = !myTurn;
    }

    function renderFinish(){
      const box = byId('finalScores');
      const players = Object.values(roomSnap.players||{});
      players.sort((a,b)=> (b.hp||0)-(a.hp||0) || (a.tokens||0)-(b.tokens||0));
      box.innerHTML = '<div class="sectionTitle">Final Standings</div>' + players.map((p,i)=>`<p>${i+1}. ${p.name} — HP ${p.hp} (tokens ${p.tokens})</p>`).join('');
    }

    // ===== Lobby actions =====
    byId('toggleReadyBtn').addEventListener('click', async ()=>{
      await db.ref(`rooms/${curRoom}/players/${uid}`).update({ ready: !(roomSnap.players?.[uid]?.ready) });
    });

    byId('startGameBtn').addEventListener('click', async ()=>{
      if(roomSnap.hostUid!==uid) return;
      const players = roomSnap.players||{}; const updates = {};
      Object.keys(players).forEach(pid=>{
        updates[`players/${pid}/hp`] = START_HP;
        updates[`players/${pid}/pos`] = 1;
        updates[`players/${pid}/tokens`] = 0;
        updates[`players/${pid}/ready`] = false;
        updates[`players/${pid}/career`] = null;
      });
      updates['state'] = 'playing';
      updates['currentTurnIndex'] = 0;
      updates['dice'] = null;
      updates['log'] = (roomSnap.log||[]).concat({ts:Date.now(), msg:'Game started!'});
      await db.ref('rooms/'+curRoom).update(updates);
    });

    byId('leaveRoomBtn').addEventListener('click', async ()=>{
      if(!curRoom) return;
      await db.ref(`rooms/${curRoom}/players/${uid}`).set(null);
      curRoom=null; roomSnap=null; show('auth');
    });

    // Host tile image setter
    byId('setTileImgBtn').addEventListener('click', async ()=>{
      if(roomSnap.hostUid!==uid) return alert('Only host can edit tiles.');
      const n = parseInt(byId('tileNum').value||''); const url = byId('tileImgUrl').value.trim();
      if(!n || n<1 || n>BOARD_LEN) return alert('Enter valid tile number.');
      await db.ref(`rooms/${curRoom}/tiles/${n}`).update({ imgUrl: url });
    });
    byId('clearTileImgBtn').addEventListener('click', async ()=>{
      if(roomSnap.hostUid!==uid) return;
      const n = parseInt(byId('tileNum').value||'');
      if(!n || n<1 || n>BOARD_LEN) return alert('Enter valid tile number.');
      await db.ref(`rooms/${curRoom}/tiles/${n}`).update({ imgUrl: '' });
    });

    // ===== Gameplay =====
    byId('rollBtn').addEventListener('click', async ()=>{
      if(roomSnap.state!=='playing') return;
      const order=roomSnap.turnOrder||[]; const turnUid=order[roomSnap.currentTurnIndex||0];
      if(turnUid!==uid) return;
      const roll = 1 + Math.floor(Math.random()*6);
      await db.ref(`rooms/${curRoom}`).update({ dice: roll });

      const meNow = roomSnap.players?.[uid];
      const newPos = Math.min(BOARD_LEN, (meNow.pos||1)+roll);
      await db.ref(`rooms/${curRoom}/players/${uid}`).update({ pos: newPos });
      await applyTile(newPos);
    });

    byId('drawBtn').addEventListener('click', async ()=>{
      if(roomSnap.state!=='playing') return;
      const order=roomSnap.turnOrder||[];
      if(order[roomSnap.currentTurnIndex||0]!==uid) return;
      await drawCard('action',1);
    });

    byId('endTurnBtn').addEventListener('click', async ()=>{
      if(roomSnap.state!=='playing') return;
      const order=roomSnap.turnOrder||[];
      if(order[roomSnap.currentTurnIndex||0]!==uid) return;
      await nextTurn();
    });

    async function logMsg(msg){
      const arr = (roomSnap.log||[]);
      arr.push({ts:Date.now(), msg});
      await db.ref('rooms/'+curRoom).update({ log: arr.slice(-300) });
    }
    async function nextTurn(){
      const order=roomSnap.turnOrder||[]; let idx=(roomSnap.currentTurnIndex||0)+1; if(idx>=order.length) idx=0;
      await db.ref('rooms/'+curRoom').update({ currentTurnIndex: idx, dice: null });
    }

    async function applyTile(pos){
      const t = (roomSnap.tiles||{})[pos]; if(!t) return;
      await logMsg(`${roomSnap.players[uid].name} lands on #${pos}: ${t.title}`);
      switch(t.action){
        case 'NONE': break;
        case 'PAYDAY': await applyPayday(t.args||{}); break;
        case 'JUMP': await moveBy(t.args?.steps||0); break;
        case 'GOTO': await moveTo(t.args?.tile||pos); break;
        case 'STOP': await applyStop(t.args?.turns||1); break;
        case 'DRAW': await drawCard(t.args?.deck||'action', t.args?.count||1); break;
        case 'FAMILY': await applyFamily(t.args||{}); break;
        case 'CHOOSE_CAREER': await chooseCareer(); break;
        case 'FINISH': await finishGame(); return;
      }
    }

    async function applyPayday(args){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      let delta = 0;
      if(args.amount) delta += args.amount;
      if(args.multiplier) delta += (meNow.hp||0) * (args.multiplier-1);
      if(args.dice) delta += (1 + Math.floor(Math.random()*6)) * (args.per||0);
      if(meNow.career?.perTurn) delta += meNow.career.perTurn;
      if(meNow.career?.dice){ delta += (1 + Math.floor(Math.random()*6)) * (meNow.career.per||20); }
      await meRef.update({ hp: (meNow.hp||0) + delta });
      await logMsg(`${meNow.name} Payday: ${delta>=0?'+':''}${delta} HP`);
    }

    async function moveBy(steps){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const newPos = Math.max(1, Math.min(BOARD_LEN, (meNow.pos||1)+steps));
      await meRef.update({ pos: newPos });
      await logMsg(`${meNow.name} ${steps>=0?'jumps':'falls'} ${steps} to ${newPos}`);
    }
    async function moveTo(tile){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const newPos = Math.max(1, Math.min(BOARD_LEN, tile));
      await meRef.update({ pos: newPos });
      await logMsg(`${meNow.name} goes to tile ${newPos}`);
    }
    async function applyStop(turns){
      await logMsg(`${roomSnap.players[uid].name} pauses for ${turns} turn(s).`);
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const skip = Math.max(0, (meNow.skip||0) + (turns||1));
      await meRef.update({ skip });
    }

    async function drawCard(deck,count){ for(let i=0;i<count;i++) await drawOne(deck); }
    async function drawOne(deck){
      const idsRef = db.ref(`rooms/${curRoom}/decks/ids/${deck}`);
      const discRef = db.ref(`rooms/${curRoom}/decks/discard/${deck}`);
      let ids = (await idsRef.get()).val()||[];
      if(ids.length===0){
        const disc=(await discRef.get()).val()||[];
        const seed = roomSnap.seed||12345;
        ids = shuffle(disc, seed+Math.floor(Math.random()*999));
        await discRef.set([]);
      }
      const cardId = ids.shift();
      await idsRef.set(ids);
      const discArr = ((roomSnap.decks?.discard?.[deck])||[]).concat(cardId);
      await discRef.set(discArr);

      const card = findCard(deck, cardId);
      await logMsg(`${roomSnap.players[uid].name} draws: ${card.title}`);
      await applyCardEffect(card.effect||{});
    }
    function findCard(deck,id){ const d=defaultDecks(); return (d[deck]||[]).find(c=>c.id===id)||{id,title:'Unknown',text:'',effect:{}}; }

    async function applyCardEffect(effect){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      switch(effect.type){
        case 'hp': await meRef.update({ hp:(meNow.hp||0)+(effect.hp||0) }); break;
        case 'token': await meRef.update({ tokens:(meNow.tokens||0)+(effect.d||0) }); break;
        case 'discardTokensForHp': {
          const take = Math.min(effect.max||0, meNow.tokens||0);
          const gain = (effect.per||0) * take;
          await meRef.update({ tokens:(meNow.tokens||0)-take, hp:(meNow.hp||0)+gain });
          break;
        }
        case 'tokenToHp': {
          if((meNow.tokens||0)>0){
            await meRef.update({ tokens:(meNow.tokens||0)-1, hp:(meNow.hp||0)+(effect.hp||0) });
          }
          break;
        }
        case 'career': {
          const career = { perTurn: effect.perTurn||0 };
          await meRef.update({ career });
          break;
        }
        case 'careerDice': {
          const career = { dice:true, per: effect.per||20 };
          await meRef.update({ career });
          break;
        }
      }
    }

    async function applyFamily(args){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      switch(args.type){
        case 'mentor': await meRef.update({ hp:(meNow.hp||0)+40 }); await logMsg('Mentor boosts +40 HP'); break;
        case 'responsibility': await meRef.update({ tokens:(meNow.tokens||0)+1 }); await logMsg('Life responsibility adds 1 token'); break;
        case 'bond': await meRef.update({ hp:(meNow.hp||0)+30 }); await logMsg('Strong bonds +30 HP'); break;
        case 'partner': await meRef.update({ hp:(meNow.hp||0)+60 }); await logMsg('Partner support +60 HP'); break;
        case 'child': await meRef.update({ hp:(meNow.hp||0)-100 }); await logMsg('New child expenses −100 HP'); break;
      }
    }

    async function chooseCareer(){
      const meNow = roomSnap.players[uid];
      const choices = defaultDecks().career;
      const pick = choices[Math.floor(Math.random()*choices.length)];
      await applyCardEffect(pick.effect);
      await logMsg(`${meNow.name} chooses a career: ${pick.title}`);
    }

    async function finishGame(){
      await db.ref('rooms/'+curRoom).update({ state:'finished', log:(roomSnap.log||[]).concat({ts:Date.now(), msg:'Finished! Tally scores.'}) });
    }

    // ===== Chat =====
    byId('sendChatBtn').addEventListener('click', async ()=>{
      if(!curRoom) return;
      const msg = byId('chatInput').value.trim();
      if(!msg) return;
      await logMsg(`${roomSnap.players?.[uid]?.name||'Player'}: ${msg}`);
      byId('chatInput').value='';
    });

    // ===== Back to lobby =====
    byId('backToLobbyBtn').addEventListener('click', async ()=>{ await db.ref('rooms/'+curRoom).update({ state:'lobby' }); });

    // ===== Create / Join =====
    function seed(){ return Math.floor(Math.random()*1e9); }
    function makeDeckIds(s){ const d=defaultDecks(); return { action: shuffle(d.action.map(c=>c.id), s+11), life: shuffle(d.life.map(c=>c.id), s+17), career: shuffle(d.career.map(c=>c.id), s+23) }; }

    async function createRoom(){
      const name = byId('playerName').value.trim();
      const avatarUrl = byId('playerAvatar').value.trim();
      if(!name) return setAuthError('Please enter a display name.');
      const code = codeGen(); const s = seed(); const deckIds = makeDeckIds(s); const tiles = defaultTiles();
      const roomRef = db.ref('rooms/'+code);
      const user = { name, avatarUrl: avatarUrl||'', hp: START_HP, pos:1, tokens:0, ready:false, connected:true, lastSeen: Date.now(), career:null };
      await roomRef.set({
        createdAt: firebase.database.ServerValue.TIMESTAMP,
        state: 'lobby',
        hostUid: uid,
        seed: s,
        decks: { ids: deckIds, discard: {action:[], life:[], career:[]} },
        tiles: Object.fromEntries(tiles.map(t=>[t.n,t])),
        players: { [uid]: user },
        turnOrder: [uid],
        currentTurnIndex: 0,
        dice: null,
        log: [ {ts: Date.now(), msg: `${name} created room ${code}`} ]
      });
      curRoom = code; attachPresence(); subscribeRoom();
    }

    async function joinRoom(){
      const name = byId('playerName').value.trim();
      const avatarUrl = byId('playerAvatar').value.trim();
      const code = byId('roomCode').value.trim().toUpperCase();
      if(!name) return setAuthError('Please enter a display name.');
      if(!code) return setAuthError('Please enter a room code.');
      const roomRef = db.ref('rooms/'+code); const snap = await roomRef.get();
      if(!snap.exists()) return setAuthError('Room not found.');
      const userRef = roomRef.child('players/'+uid);
      const user = { name, avatarUrl: avatarUrl||'', hp: START_HP, pos:1, tokens:0, ready:false, connected:true, lastSeen: Date.now(), career:null };
      await userRef.update(user);
      await roomRef.child('turnOrder').transaction(arr=>{ if(!arr) return [uid]; if(!arr.includes(uid)) arr.push(uid); return arr; });
      curRoom = code; attachPresence(); subscribeRoom();
    }

    byId('createRoomBtn').addEventListener('click', createRoom);
    byId('joinRoomBtn').addEventListener('click', joinRoom);

    // ===== Auth =====
    auth.onAuthStateChanged(async user => {
      if(user){ uid = user.uid; show('auth'); }
      else { await auth.signInAnonymously(); }
    });
  })();
</script>

<!--
  ==============================
  Realtime Database Rules (prototype)
  ==============================
  Use test rules while prototyping; then lock down.

  {
    "rules": {
      ".read": true,
      ".write": true
    }
  }
-->
</body>
</html>
