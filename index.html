<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HustleLife — Black can crack</title>
  <style>
    :root { --bg:#0b0d10; --panel:#12151a; --ink:#e6e9ef; --muted:#9aa4b2; --brand:#6ee7ff; --accent:#a78bfa; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:1100px;margin:0 auto;padding:16px}
    .card{background:var(--panel);border:1px solid #222834;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .row{display:flex;gap:12px;align-items:center}
    .col{display:flex;flex-direction:column;gap:8px}
    .grid{display:grid;gap:12px}
    .grid2{grid-template-columns:1fr 1fr}
    .btn{background:#1f2937;border:1px solid #374151;color:var(--ink);padding:10px 14px;border-radius:12px;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn.brand{border-color:#1a2a36;background:#0f1b24;color:#c9f2ff}
    .btn.ok{border-color:#16301f;background:#0e1f14;color:#d6ffe3}
    .btn.warn{border-color:#3a2b10;background:#1f1608;color:#ffe6b8}
    input,select,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a2f3a;background:#0e1116;color:#e6e9ef}
    label{font-size:12px;color:#9aa4b2}
    .sectionTitle{font-weight:700;letter-spacing:.3px;color:#cbd5e1}
    .muted{color:#9aa4b2}
    .tag{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0e1821;border:1px solid #1f2a36;color:#b8deff}
    .players{display:flex;gap:10px;flex-wrap:wrap}
    .pCard{display:flex;flex-direction:column;gap:4px;align-items:center;background:#0e1116;border:1px solid #232833;border-radius:12px;padding:10px;width:140px}
    .pCard img{width:64px;height:64px;border-radius:12px;object-fit:cover;border:1px solid #2a2f3a;background:#090c10}
    .boardWrap{overflow:auto;border:1px solid #232833;border-radius:14px;background:#0a0d12}
    .board{position:relative;display:grid;grid-template-columns:repeat(40, 120px);gap:8px;padding:12px}
    .tile{position:relative;border:1px solid #2b3240;border-radius:12px;padding:8px;background:#0f131a;min-height:120px}
    .tile h4{margin:0 0 6px 0;font-size:12px;color:#cbd5e1}
    .tile p{margin:0;font-size:11px;color:#aab3c0}
    .tile .img{position:absolute;inset:0;border-radius:11px;background:#0a0d12;background-size:cover;background-position:center;opacity:.25}
    .tile .num{position:absolute;top:6px;right:8px;font-size:11px;color:#8aa3b8}
    .tile .action{position:absolute;bottom:8px;left:8px;font-size:10px;color:#89f7d1;background:#06231b;border:1px solid #0c3d31;padding:2px 6px;border-radius:8px}
    .tokens{position:absolute;bottom:6px;right:6px;display:flex;gap:2px;flex-wrap:wrap}
    .token{width:18px;height:18px;border-radius:6px;border:1px solid #2a2f3a;background:#0e1116;overflow:hidden}
    .token img{width:100%;height:100%;object-fit:cover}
    .hud{display:grid;grid-template-columns:1.1fr 1.9fr;gap:12px;margin-top:12px}
    .pane{background:#0e1116;border:1px solid #232833;border-radius:12px;padding:12px}
    .log{max-height:220px;overflow:auto;background:#091017;border:1px solid #162033;border-radius:10px;padding:8px}
    .log p{margin:0 0 6px 0;color:#a8c1d4;font-size:12px}
    .badge{padding:2px 6px;border:1px solid #2d3a31;border-radius:999px;background:#0c1c14;color:#bfead0;font-size:11px}
    .inlineForm{display:flex;gap:8px}
    .small{font-size:12px}
    .danger{color:#ffb3b3}
    .diceWrap{display:flex;align-items:center;gap:12px}
    .dice{width:84px;height:84px;background:#eaeef5;border-radius:16px;border:4px solid #c7d0dc;box-shadow:inset 0 6px 14px rgba(0,0,0,.2), 0 8px 18px rgba(0,0,0,.25);display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);padding:8px;transition:transform .35s ease}
    .dice.roll{transform:rotate(20deg)}
    .pip{width:14px;height:14px;background:#1b2430;border-radius:999px;justify-self:center;align-self:center}
    .pip.hide{visibility:hidden}
    .piles{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .pile{width:140px;height:90px;border-radius:12px;border:2px dashed #28405a;background:#0b1622;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:not-allowed;opacity:.5}
    .pile.active{border-style:solid;background:#0f2133;cursor:pointer;opacity:1}
    .pile h4{margin:0;font-size:13px;color:#cfe7ff}
    .pile .sub{font-size:11px;color:#8fb6db}
    #choicePanel{display:none;margin-top:10px}
    #choicePanel .btn{padding:8px 12px}
    .popup{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55);z-index:50}
    .popup.show{display:flex}
    .popupCard{max-width:560px;width:90%;background:#0f141b;border:1px solid #28303c;border-radius:14px;padding:16px;box-shadow:0 20px 40px rgba(0,0,0,.35)}
    .popupCard h3{margin:0 0 6px 0}
    .popupCard p{margin:0 0 10px 0;color:#b6c2d1}

    /* NEW: full image inside tile popup */
    .popupImg{
      width:100%;
      aspect-ratio:16/9;
      background-size:cover;
      background-position:center;
      border-radius:10px;
      border:1px solid #28303c;
      margin:10px 0;
      display:none;
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>HustleLife — Aadarsh in Paris</h1>
  <p class="muted">Create/join rooms, play in real time, add images to tiles, and use any image URL as your player token.</p>

  <!-- Auth / Join -->
  <div id="authScreen" class="card" style="display:none">
    <div class="grid grid2">
      <div class="col">
        <div class="sectionTitle">Your Player</div>
        <label>Display name</label>
        <input id="playerName" placeholder="e.g., NibbaAadarsh" />
        <label>Avatar image URL (internet or Google Drive public link)</label>
        <input id="playerAvatar" placeholder="https://..." />
        <div class="row">
          <div class="pCard" style="width:auto">
            <img id="avatarPreview" src="" alt="avatar" />
            <div class="small muted">Preview</div>
          </div>
        </div>
        <div class="small muted">Google Drive tip: use <code>https://drive.google.com/uc?export=view&id=FILE_ID</code></div>
      </div>
      <div class="col">
        <div class="sectionTitle">Room</div>
        <label>Room code</label>
        <input id="roomCode" placeholder="e.g., 5-letter code" maxlength="8" />
        <div class="row">
          <button class="btn brand" id="createRoomBtn">Create Room</button>
          <button class="btn" id="joinRoomBtn">Join Room</button>
        </div>
        <div class="small muted">Creating a room generates a new 5-letter code.</div>
        <div id="authError" class="small danger"></div>
      </div>
    </div>
  </div>

  <!-- Lobby -->
  <div id="lobbyScreen" class="card" style="display:none">
    <div class="row" style="justify-content:space-between">
      <div class="sectionTitle">Lobby · Room <span id="lobbyCode"></span></div>
      <div class="row">
        <span class="tag">Host: <span id="hostTag">–</span></span>
        <button class="btn" id="leaveRoomBtn">Leave</button>
      </div>
    </div>
    <div class="players" id="playerList"></div>
    <div class="row" style="margin-top:8px;gap:8px">
      <button class="btn ok" id="toggleReadyBtn">Ready</button>
      <button class="btn brand" id="startGameBtn" disabled>Start Game</button>
    </div>
  </div>

  <!-- Game -->
  <div id="gameScreen" class="card" style="display:none">
    <div class="row" style="justify-content:space-between;align-items:flex-start">
      <div>
        <div class="sectionTitle">Room <span id="gameCode"></span></div>
        <div class="small muted">Turn: <span id="turnName">–</span></div>
      </div>
      <div class="row">
        <div class="diceWrap">
          <div id="dice" class="dice" title="Dice">
            <div class="pip" data-pos="1"></div>
            <div class="pip" data-pos="2"></div>
            <div class="pip" data-pos="3"></div>
            <div class="pip" data-pos="4"></div>
            <div class="pip" data-pos="5"></div>
            <div class="pip" data-pos="6"></div>
            <div class="pip" data-pos="7"></div>
            <div class="pip" data-pos="8"></div>
            <div class="pip" data-pos="9"></div>
          </div>
          <button class="btn" id="rollBtn">Roll</button>
          <button class="btn warn" id="stealBtn">Attempt Steal</button>
          <button class="btn" id="endTurnBtn">End Turn</button>
        </div>
      </div>
    </div>

    <div class="boardWrap" style="margin-top:12px">
      <div class="board" id="board"></div>
    </div>

    <div class="hud">
      <div class="pane">
        <div class="sectionTitle">Players</div>
        <div id="playersHUD" class="players"></div>

        <div class="sectionTitle" style="margin-top:10px">Draw Piles</div>
        <div class="piles">
          <div class="pile" id="pile-action"><h4>Action Deck</h4><div class="sub" id="pile-action-sub">Inactive</div></div>
          <div class="pile" id="pile-life"><h4>Life Deck</h4><div class="sub" id="pile-life-sub">Inactive</div></div>
          <div class="pile" id="pile-career"><h4>Career Deck</h4><div class="sub" id="pile-career-sub">Inactive</div></div>
        </div>

        <!-- Path choice (tile 15) -->
        <div id="choicePanel" class="pane">
          <div class="sectionTitle">Path Choice</div>
          <div class="small muted">College: Jump +5 · Street Hustle: Draw from Action</div>
          <div class="row" style="margin-top:6px">
            <button class="btn ok" id="collegeBtn">Choose College</button>
            <button class="btn warn" id="streetBtn">Choose Street Hustle</button>
          </div>
        </div>
      </div>

      <div class="pane">
        <div class="sectionTitle">Log</div>
        <div id="log" class="log"></div>
        <div class="row" style="margin-top:8px">
          <input id="chatInput" placeholder="Message" />
          <button class="btn" id="sendChatBtn">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Finish -->
  <div id="finishScreen" class="card" style="display:none">
    <div class="sectionTitle">Game Over</div>
    <div id="finalScores"></div>
    <div class="row" style="margin-top:10px">
      <button class="btn" id="backToLobbyBtn">Back to Lobby</button>
    </div>
  </div>
</div>

<!-- Shared Popup (tiles, cards, events) -->
<div id="tilePopup" class="popup">
  <div class="popupCard">
    <div class="small muted" id="popupWho">–</div>
    <h3 id="popupTitle">Title</h3>
    <!-- NEW: full image area for tile popups -->
    <div id="popupImage" class="popupImg"></div>
    <p id="popupDesc">Description</p>
    <div class="row" style="justify-content:flex-end">
      <button class="btn" id="popupClose">Close</button>
    </div>
  </div>
</div>

<!-- Steal Target Popup -->
<div id="stealPopup" class="popup">
  <div class="popupCard">
    <h3>Choose a target</h3>
    <p class="small muted">Attempt Steal (consumes your turn). Roll 5–6 → steal 100 HP and give target +1 Trauma Token. Roll 1–4 → you lose 50 HP and gain +1 Trauma Token.</p>
    <label for="stealTarget">Player</label>
    <select id="stealTarget"></select>
    <div class="row" style="justify-content:flex-end;margin-top:8px">
      <button class="btn" id="stealCancel">Cancel</button>
      <button class="btn warn" id="stealConfirm">Attempt</button>
    </div>
  </div>
</div>

<!-- Firebase compat -->
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-database-compat.js"></script>

<script>
  // ---- Your Firebase config ----
  const firebaseConfig = {
    apiKey: "AIzaSyAEqutXCO5OZD6VU_ohaBxNfh7G8Q6PEy0",
    authDomain: "nomercy-8269a.firebaseapp.com",
    databaseURL: "https://nomercy-8269a-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "nomercy-8269a",
    storageBucket: "nomercy-8269a.firebasestorage.app",
    messagingSenderId: "349047620790",
    appId: "1:349047620790:web:3206ff81cb7f5413d29217",
    measurementId: "G-1WX7CWBFGF"
  };

  (function boot(){
    const app = firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db   = firebase.database();

    // ===== UI helpers =====
    const byId = id => document.getElementById(id);
    const screens = { auth: byId('authScreen'), lobby: byId('lobbyScreen'), game: byId('gameScreen'), finish: byId('finishScreen') };
    const show = k => { Object.values(screens).forEach(s=>s.style.display='none'); screens[k].style.display='block'; };
    const setAuthError = msg => byId('authError').textContent = msg;
    const cap = s => s ? s.charAt(0).toUpperCase()+s.slice(1) : '';

    // Preview avatar
    const avatarInput = byId('playerAvatar');
    const avatarPreview = byId('avatarPreview');
    avatarInput.addEventListener('input', () => { avatarPreview.src = avatarInput.value || '' });

    // Popups
    const popup = byId('tilePopup'),
          popupTitle = byId('popupTitle'),
          popupDesc = byId('popupDesc'),
          popupWho = byId('popupWho'),
          popupImg = byId('popupImage');
    byId('popupClose').onclick = () => popup.classList.remove('show');

    const stealPopup = byId('stealPopup'), stealTarget = byId('stealTarget');
    byId('stealCancel').onclick = () => stealPopup.classList.remove('show');

    // Dice helpers
    const diceEl = byId('dice');
    const pips = Array.from(diceEl.querySelectorAll('.pip'));
    const faces = { 1:[5], 2:[1,9], 3:[1,5,9], 4:[1,3,7,9], 5:[1,3,5,7,9], 6:[1,3,4,6,7,9] };
    function renderDie(n){ pips.forEach(p=>p.classList.add('hide')); (faces[n]||[]).forEach(i=>pips[i-1].classList.remove('hide')); }
    renderDie(1);

    // ===== State =====
    let uid = null, curRoom = null, roomSnap = null;
    const START_HP = 100, BOARD_LEN = 40;

    // ===== Model: Decks =====
    function defaultDecks(){
      const action = [
        {id:'a1', title:'Push Through', text:'Convert 1 challenge token to +30 HP.', effect:{type:'tokenToHp', hp:30}},
        {id:'a2', title:'Small Win', text:'+50 HP from a clever shortcut.', effect:{type:'hp', hp:50}},
        {id:'a3', title:'Unexpected Bill', text:'-40 HP. Ouch.', effect:{type:'hp', hp:-40}},
      ];
      const life = [
        {id:'l1', title:'Scholarship', text:'+100 HP. Use wisely.', effect:{type:'hp', hp:100}},
        {id:'l2', title:'Setback', text:'Gain 1 challenge token.', effect:{type:'token', d:1}},
        {id:'l3', title:'Therapy Session', text:'Discard up to 2 tokens, +20 HP each.', effect:{type:'discardTokensForHp', per:20, max:2}},
      ];
      const career = [
        {id:'c1', title:'Apprentice', text:'+40 HP per Payday turn.', effect:{type:'career', perTurn:40}},
        {id:'c2', title:'Analyst', text:'+60 HP per Payday turn.', effect:{type:'career', perTurn:60}},
        {id:'c3', title:'Creator', text:'Roll-based income (D6×20) on Payday.', effect:{type:'careerDice', per:20}},
      ];
      return { action, life, career };
    }

    // ===== Tile images (embedded) =====
    const g = (id) => `https://lh3.googleusercontent.com/d/${id}=w1200`;
    const tileImgs = {
      1:g("1Kuomy4AfX4eB1CAz38hKhaIwHu_Om-Ij"),
      2:g("1XVdyUMvdGRPyhZUNKkodBSCT2pL4WFym"),
      3:g("1U1yjdVfD2M7hlcXd27nDM_0FRt97sKfa"),
      4:g("1OED-tX-_G61XP5ODsctQqbM2S3j-GdF9"),
      5:g("1i_3dQxVAhB7SZKi8RCv5hC4H_z4zozsM"),
      6:g("1shVjprj06J6Gq8sgF2y1Y3mSKw9KUBxL"),
      7:g("1gQfYd2sGvu4lEiEkw6G_ILECTNjZ0fHl"),
      8:g("1sFqtKwqw27KA7VulOX4XW55FRNHgITjq"),
      9:g("1Y0F8GldGzD0IzXcHYj-sj__LdLSz5PSZ"),
      10:g("1f4k3wTgrX061I5g4Wnqht1lcJU8xNfg4"),
      11:g("1buMwfCKviPIqUt33tIYpDqcCGZKKoDt9"),
      12:g("1p24c0QpFoZEMLueeF5lN_LocgQJIG6Or"),
      13:g("1CXOT8zf-FvfXxfZUFQxYwiYP2d7XK86B"),
      14:g("14cZ-IhJAoDS39WqHr6sZzCppzwPDKF4l"),
      15:g("1QN3n6zuwUzT0BV3ro1CmxxPV6gKrBFUf"),
      16:g("1w35G7hfuY0v1fWdCQr5WC_aWxw1vkY26"),
      17:g("1FldHQVC0Df2ozA0G2NBKEOBday9ULkbD"),
      18:g("1kJUiBtAFz74ipsJ3eCAdHI7-tuXVDMYs"),
      19:g("1T9p_wU17pXMxzbQFqNRuRo3u9VsCzYOk"),
      20:g("1RS3NLnSP_9gOyeLxxM7HceTNX2CaHBNV"),
      21:g("1QOO_WolxEZa8nZYQ3hRQ08kJNLSD_mwX"),
      22:g("1dEdjM8pp_XnvtHC9baCTCT5cDcFMCkpz"),
      23:g("19uxsHpAxNuYmrBoIL2yQ0aFMSuTmwA1k"),
      24:g("1cLJ71h9NsvmX7UlaVLpgbowQ-3mqiud"),
      25:g("1CdbJrqIzacrilK8jvD4jDki4qGQHFR1W"),
      26:g("1isggTXWeoN7_io6i4L6LkLMMpLcDCOrC"),
      27:g("1X7QoGlF6UlSYLMJ3fXPck4eXENl7dKhH"),
      28:g("1q2V_odYq6PfnRA0vQx5IJVIuGuH95awA"),
      29:g("13ikv1IO-ZHVmtQYLFo3WMPnDcRJh5o8S"),
      30:g("14R1624aIOY0CNFB1yRHD1Yp8t09m1tDF"),
      31:g("19XvIwnggY5DGVCD1I-p0vLf2c75LWrp9"),
      32:g("1iTcWyZrARp0EMB6gJ5G8ii0WDCZwyB5q"),
      33:g("1Sp90-hkiF8vWep8e9t7Twlw3cfel9jJE"),
      34:g("1t88AwY07xROvuOkyq0EMbmMc2chTijcG"),
      35:g("1lrcACad8Ka1o4M7-hyQVTlAWQas4vWsF"),
      36:g("1SS1BdbNtVVU0O5bSD_aFlriASqxcLkWQ"),
      37:g("1W_zqtMQQp4iuzXm2nlGXSrZ_T3mtgU_A"),
      38:g("142fAQKmPIOgQG6CQDqAncZXkR2ACL6Cj"),
      39:g("1I3DNGDfvdZuPT_2LTni3jymx7gucuVGw"),
      40:g("16eLdh96fLa0Y8QTqSpKJ-UexvkrQasH7"),
    };

    // ===== Tiles (with embedded images) =====
    function defaultTiles(){
      const t=[];
      const push=(n,title,description,action,args={})=>t.push({n,title,description,action,args,imgUrl: tileImgs[n] || ''});
      // Childhood (1–10)
      push(1,'Start: Born in the Hood','You enter the world in a underfunded hospital. Nurses say, "Another fighter." Grab your diaper bag and hustle.','PAYDAY',{amount:50});
      push(2,'First Steps','Toddling around the projects, dodging broken glass. Mom says, "Stay inside, baby."','NONE');
      push(3,'Dad Left','Your Black dad bounced for cigarettes and never came back. Classic absentee trope—now it\'s single-mom grind time.','DRAW',{deck:'life',count:1});
      push(4,'Fried Chicken Feast','Auntie\'s Sunday dinner: You ate fried chicken till you burst. Stereotype alert—soul food hits different.','PAYDAY',{amount:30});
      push(5,'Domestic Chaos','You witness dad beat your mom before he splits for good. Cops called, but they side with him. Heartbreaking reality check.','STOP',{turns:1, tokensAdd:2});
      push(6,'Watermelon Summers','Block party vibes: You ate lots of watermelon, juice dripping everywhere. Media says it\'s a "thing"—eye roll.','JUMP',{steps:2});
      push(7,'First Racism Encounter','Teacher calls you "aggressive" for raising your hand. Welcome to microaggressions 101.','DRAW',{deck:'action',count:1});
      push(8,'Corner Store Run','Sent to get milk—store owner follows you around like you\'re a thief.','NONE',{hpIfLt:{lt:50,delta:-10}});
      push(9,'Block Friends','Made your first crew—playing hoops till dark. Bonds for life... or trouble.','FAMILY',{type:'mentor'});
      push(10,'End of Innocence','Saw your first drive-by. Hood life\'s getting real.','GOTO',{tile:11});
      // Teen Years (11–20)
      push(11,'High School Start','Freshman year in overcrowded school. Books outdated, dreams big.','CHOOSE_CAREER',{preview:true});
      push(12,'Police Brutality Intro','Stopped for "fitting the description." Roughed up, no charges—trauma lingers.','JUMP',{steps:-3, tokensAdd:2});
      push(13,'Racism in Class','Classmate drops the N-word "as a joke." Teacher laughs it off. Systemic BS.','DRAW',{deck:'life',count:1});
      push(14,'Side Hustle Begins','Selling candy at school—entrepreneur vibes.','PAYDAY',{amount:100});
      push(15,'Path Choice','Fork in the road: College dreams or street smarts?','CHOOSE_CAREER',{branch:true});
      push(16,'Fried Chicken Cravings','Late-night Popeyes run. You ate fried chicken like it\'s therapy.','NONE');
      push(17,'Family Drama Escalates','Mom\'s new boyfriend echoes dad\'s violence. Cycle continues.','FAMILY',{type:'partner', hpDelta:-50});
      push(18,'Watermelon Stereotype Mock','Friends roast you for loving watermelon. "Black card revoked?" Nah, own it.','JUMP',{steps:1});
      push(19,'Activism Spark','Join school protest against racism. Eyes opened.','DRAW',{deck:'action',count:1});
      push(20,'Teen Graduation','Cap and gown, but half your class dropped out. Bitter-sweet.','PAYDAY',{amount:200});
      // Adulthood Grind (21–30)
      push(21,'First Real Job','Entry-level gig—boss micro-manages \'cause you\'re Black.','CHOOSE_CAREER',{lock:true});
      push(22,'Police Brutality Strike','Traffic stop gone wrong—you got beaten, viral video optional.','GOTO',{tile:15, tokensAdd:3});
      push(23,'Racism at Work','Denied promotion: "Not a culture fit." Code for bias.','STOP',{turns:1, hpDelta:-100});
      push(24,'Hustle Payoff','Side gig blows up—music or business.','PAYDAY',{dice:true,per:50});
      push(25,'Dad Returns? Nah','Ghost dad texts for money. Abandonment scars reopen.','DRAW',{deck:'life',count:1});
      push(26,'Fried Chicken Comfort','Stress eating: You ate fried chicken to cope with the grind.','NONE');
      push(27,'Domestic Echo','In your relationship, patterns from childhood emerge—violence creeps in.','FAMILY',{type:'child', tokensAdd:2});
      push(28,'Watermelon Festival','Community event: You ate lots of watermelon, reclaiming the stereotype.','JUMP',{steps:3});
      push(29,'Systemic Setback','Evicted due to gentrification. Hood changing.','JUMP',{steps:-5});
      push(30,'Grind Milestone','Bought your first ride—freedom on wheels.','DRAW',{deck:'action',count:1});
      // Family Legacy (31–35)
      push(31,'Marriage Milestone','Tied the knot—hoping to break cycles.','FAMILY',{type:'partner', spouseBonusPerPayday:20});
      push(32,'Kid Arrives','Bundle of joy, but bills stack up.','FAMILY',{type:'child', hpDelta:-100});
      push(33,'Family Racism Hit','In-laws drop racist vibes at dinner.','DRAW',{deck:'life',count:1});
      push(34,'Police Family Scare','Cops harass your teen kid—brutality cycle.','STOP',{turns:1, tokensAdd:1});
      push(35,'Legacy Reflection','Teaching kids about dad leaving, violence, stereotypes—breaking chains.','NONE',{redeemAllTokensMultiplier:true});
      // Boss Status (36–40)
      push(36,'Big Break','Viral success or business boom. Made it?','PAYDAY',{multiplier:2});
      push(37,'Final Racism Hurdle','Even at the top, "imposter syndrome" from years of bias.','DRAW',{deck:'action',count:1});
      push(38,'Police Flashback','Old brutality case payout—justice?','NONE',{payIfTokensGT:{gt:3, amount:300}});
      push(39,'Stereotype Roast','Memoir drops: "I Ate Fried Chicken and Watermelon—And Survived the Hood."','NONE');
      push(40,'Finish: Boss Status','Mansion, community center, or exile—your hood story ends. Tally up.','FINISH');
      return t;
    }

    // ===== Presence =====
    function codeGen(){ const abc='ABCDEFGHJKMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<5;i++) s+=abc[Math.floor(Math.random()*abc.length)]; return s; }
    function attachPresence(){
      const pRef = db.ref(`rooms/${curRoom}/players/${uid}/connected`);
      const lastRef = db.ref(`rooms/${curRoom}/players/${uid}/lastSeen`);
      pRef.set(true); lastRef.set(Date.now());
      pRef.onDisconnect().set(false);
      lastRef.onDisconnect().set(Date.now());
    }
    function subscribeRoom(){
      db.ref('rooms/'+curRoom).on('value', snap => {
        roomSnap = snap.val();
        if(!roomSnap){ show('auth'); return; }
        render();
      });
    }

    // ===== Renderers =====
    function render(){
      if(!roomSnap){ show('auth'); return; }
      const state = roomSnap.state;
      if(state==='lobby'){ renderLobby(); show('lobby'); }
      else if(state==='playing'){ renderGame(); show('game'); }
      else if(state==='finished'){ renderFinish(); show('finish'); }

      const pop = roomSnap.popup;
      if(pop && pop.ts){
        popupTitle.textContent = pop.title || (pop.kind==='card' ? 'Card' : 'Event');
        popupDesc.textContent = pop.description || '';

        if(pop.kind==='card'){
          popupWho.textContent = `${pop.player||'Someone'} drew a ${cap(pop.deck)} card`;
          if (popupImg) popupImg.style.display = 'none';
        } else if(pop.kind==='tile'){
          popupWho.textContent = `${pop.player||'Someone'} landed on #${pop.n}`;
          // show the tile's full image if present
          const t = (roomSnap.tiles || {})[pop.n];
          const url = t && t.imgUrl ? t.imgUrl : '';
          if (popupImg) {
            if (url) {
              popupImg.style.backgroundImage = `url('${url}')`;
              popupImg.style.display = 'block';
            } else {
              popupImg.style.display = 'none';
            }
          }
        } else if(pop.kind==='event'){
          popupWho.textContent = pop.player || '–';
          if (popupImg) popupImg.style.display = 'none';
        } else {
          popupWho.textContent = pop.player || '–';
          if (popupImg) popupImg.style.display = 'none';
        }
        popup.classList.add('show');
      }

      const logBox = byId('log');
      if(logBox && roomSnap.log){
        logBox.innerHTML = roomSnap.log.slice(-200).map(e=>`<p>${new Date(e.ts).toLocaleTimeString()} — ${e.msg}</p>`).join('');
        logBox.scrollTop = logBox.scrollHeight;
      }
    }
    function renderLobby(){
      byId('lobbyCode').textContent = curRoom;
      byId('hostTag').textContent = roomSnap.players?.[roomSnap.hostUid]?.name || '–';
      const list = byId('playerList'); list.innerHTML='';
      Object.entries(roomSnap.players||{}).forEach(([id,p])=>{
        const el = document.createElement('div'); el.className='pCard';
        el.innerHTML = `<img src="${p.avatarUrl||''}" alt="avatar">
                        <div>${p.name||'?'}</div>
                        <div class="badge">HP ${p.hp ?? 0}</div>
                        <div class="muted small">Trauma Tokens ${p.tokens ?? 0}</div>
                        <div class="muted small">${p.ready?'Ready ✅':'Not ready'}</div>`;
        list.appendChild(el);
      });
      const players = Object.values(roomSnap.players||{});
      const allReady = players.length>=2 && players.every(p=>p.ready);
      byId('startGameBtn').disabled = !((roomSnap.hostUid===uid) && allReady);
    }

    // ===== HUD/Game render =====
    function renderGame(){
      byId('gameCode').textContent = curRoom;
      const turnIdx = roomSnap.currentTurnIndex||0;
      const order = roomSnap.turnOrder||[];
      const turnUid = order[turnIdx];
      byId('turnName').textContent = roomSnap.players?.[turnUid]?.name || '–';

      const hud = byId('playersHUD'); hud.innerHTML='';
      Object.entries(roomSnap.players||{}).forEach(([id,p])=>{
        const card = document.createElement('div'); card.className='pCard';
        card.innerHTML = `<img src="${p.avatarUrl||''}">
                          <div>${p.name||'?'}</div>
                          <div class="badge">HP ${p.hp ?? 0}</div>
                          <div class="muted small">Trauma Tokens ${p.tokens ?? 0}</div>
                          <div class="muted small">${id===turnUid?'(turn)':''}</div>`;
        hud.appendChild(card);
      });

      const board = byId('board'); board.innerHTML='';
      const playersByTile = {};
      Object.entries(roomSnap.players||{}).forEach(([id,p])=>{
        const k=String(p.pos||1); (playersByTile[k] ||= []).push(p);
      });
      for(let i=1;i<=BOARD_LEN;i++){
        const t = (roomSnap.tiles||{})[i] || {n:i,title:`Tile ${i}`,description:'',action:'NONE',args:{},imgUrl:''};
        const div = document.createElement('div'); div.className='tile';
        if(t.imgUrl){ const im=document.createElement('div'); im.className='img'; im.style.backgroundImage = `url('${t.imgUrl}')`; div.appendChild(im); }
        div.innerHTML += `<div class="num">#${i}</div><h4>${t.title||''}</h4><p>${t.description||''}</p><div class="action">${t.action}</div>`;
        const tokWrap = document.createElement('div'); tokWrap.className='tokens';
        (playersByTile[String(i)]||[]).forEach(p=>{
          const tok=document.createElement('div'); tok.className='token'; tok.title=`${p.name} — HP ${p.hp ?? 0} — Trauma Tokens ${p.tokens ?? 0}`;
          tok.innerHTML=`<img src="${p.avatarUrl||''}">`; tokWrap.appendChild(tok);
        });
        div.appendChild(tokWrap); board.appendChild(div);
      }

      const pending = roomSnap.pendingDraw || null;
      const meTurn = (order[turnIdx]===uid);
      const rolled = !!(roomSnap.turn && roomSnap.turn.rolled);
      const crisis = (roomSnap.pendingCrisis && roomSnap.pendingCrisis.uid===uid) ? true : false;
      const me = roomSnap.players?.[uid];

      function setPileState(kind, active, text){
        const el = byId(`pile-${kind}`), sub = byId(`pile-${kind}-sub`);
        if(active){ el.classList.add('active'); el.style.cursor='pointer'; }
        else { el.classList.remove('active'); el.style.cursor='not-allowed'; }
        sub.textContent = text || (active ? 'Click to draw' : 'Inactive');
      }
      setPileState('action', pending && meTurn && pending.uid===uid && pending.deck==='action', pending?.deck==='action'?`Draw ${pending.count}`:'Inactive');
      setPileState('life',   pending && meTurn && pending.uid===uid && pending.deck==='life',   pending?.deck==='life'?`Draw ${pending.count}`:'Inactive');
      setPileState('career', pending && meTurn && pending.uid===uid && pending.deck==='career', pending?.deck==='career'?`Draw ${pending.count}`:'Inactive');

      if(typeof roomSnap.dice === 'number'){ renderDie(roomSnap.dice); }

      const hasSkip = (me?.skip||0)>0;
      const hasChoice = !!(roomSnap.pendingChoice && roomSnap.pendingChoice.uid===uid);
      const canActBase = meTurn && !rolled && !pending && !hasChoice && !crisis && !hasSkip;

      byId('stealBtn').style.display = canActBase ? 'inline-block' : 'none';
      byId('stealBtn').disabled = !canActBase;

      byId('rollBtn').textContent = crisis ? 'Crisis Roll' : 'Roll';
      byId('rollBtn').disabled = !meTurn || (crisis ? false : (rolled || pending || hasChoice || hasSkip));
      byId('endTurnBtn').disabled = !meTurn || (crisis ? true : (!rolled || pending || hasChoice));

      const choicePanelEl = document.getElementById('choicePanel');
      if (choicePanelEl) {
        choicePanelEl.style.display = (hasChoice && meTurn) ? 'block' : 'none';
      }

      if(roomSnap.state==='playing' && roomSnap.hostUid===uid){
        const tuid = turnUid;
        const p = roomSnap.players?.[tuid];
        if(!tuid || !p || p.connected===false){
          nextTurn(true);
        }
        const pc = roomSnap.pendingChoice;
        if (pc) {
          const orderArr = roomSnap.turnOrder || [];
          const curIdx = roomSnap.currentTurnIndex || 0;
          const curUid = orderArr[curIdx];
          if (curUid !== pc.uid) {
            const wantIdx = orderArr.indexOf(pc.uid);
            if (wantIdx !== -1) {
              firebase.database().ref('rooms/'+curRoom).update({
                currentTurnIndex: wantIdx,
                turn: { rolled: false }
              });
            }
          }
        }
      }
    }

    function renderFinish(){
      const box = byId('finalScores');
      const players = Object.values(roomSnap.players||{});
      players.sort((a,b)=> (b.hp||0)-(a.hp||0) || (a.tokens||0)-(b.tokens||0));
      box.innerHTML = '<div class="sectionTitle">Final Standings</div>' + players.map((p,i)=>`<p>${i+1}. ${p.name} — HP ${p.hp} (Trauma Tokens ${p.tokens})</p>`).join('');
    }

    // ===== Helpers for HP/Trauma/Burnout/Crisis =====
    async function addHpTo(uidX, delta){
      const p = roomSnap.players[uidX] || {};
      await db.ref(`rooms/${curRoom}/players/${uidX}`).update({ hp:(p.hp||0)+delta });
    }
    async function addHp(delta){ return addHpTo(uid, delta); }

    async function addTokensTo(uidX, delta){
      const p = roomSnap.players[uidX] || {};
      const newT = Math.max(0, (p.tokens||0) + delta);
      await db.ref(`rooms/${curRoom}/players/${uidX}`).update({ tokens:newT });
      if(uidX===uid) await checkBurnout();
    }
    async function addTokens(delta){ return addTokensTo(uid, delta); }

    async function checkBurnout(){
      const me = (roomSnap.players||{})[uid] || {};
      const tokens = me.tokens||0;
      const burned = !!me.burnedOut;
      if(tokens >= 5 && !burned){
        const skip = Math.max(0,(me.skip||0)+1);
        await db.ref(`rooms/${curRoom}/players/${uid}`).update({ skip, burnedOut:true });
        await logMsg(`${me.name} hits Burnout (5+ Trauma Tokens): loses next turn.`);
      } else if(tokens < 5 && burned){
        await db.ref(`rooms/${curRoom}/players/${uid}`).update({ burnedOut:false });
      }
      if(tokens >= 6 && !(roomSnap.pendingCrisis && roomSnap.pendingCrisis.uid===uid)){
        await db.ref('rooms/'+curRoom+'/pendingCrisis').set({ uid });
        await logMsg(`${me.name} must take a Crisis Roll (rolling a 1 or 2 triggers a Crisis Reset).`);
      }
    }
    async function crisisReset(){
      const me = roomSnap.players[uid];
      await db.ref(`rooms/${curRoom}/players/${uid}`).update({
        hp: 0, pos: 1, tokens: 0, skip: (me.skip||0)+1
      });
      await logMsg(`${me.name} undergoes a Crisis Reset: back to start, HP 0, Trauma cleared, skip next turn.`);
    }

    // ===== Lobby actions =====
    byId('toggleReadyBtn').addEventListener('click', async ()=>{
      await db.ref(`rooms/${curRoom}/players/${uid}`).update({ ready: !(roomSnap.players?.[uid]?.ready) });
    });
    byId('startGameBtn').addEventListener('click', async ()=>{
      if(roomSnap.hostUid!==uid) return;
      const players = roomSnap.players || {};
      const updates = {};

      // ---- FIX: preserve existing join order & include any newcomers ----
      const existing = (roomSnap.turnOrder || []).filter(id => players[id]);
      const newcomers = Object.keys(players).filter(id => !existing.includes(id));
      const order = existing.concat(newcomers);
      // -------------------------------------------------------------------

      Object.keys(players).forEach(pid=>{
        updates[`players/${pid}/hp`] = START_HP;
        updates[`players/${pid}/pos`] = 1;
        updates[`players/${pid}/tokens`] = 0;
        updates[`players/${pid}/ready`] = false;
        updates[`players/${pid}/career`] = null;
        updates[`players/${pid}/skip`] = 0;
        updates[`players/${pid}/burnedOut`] = false;
      });
      const tiles = defaultTiles();
      updates['tiles'] = Object.fromEntries(tiles.map(t=>[t.n,t]));
      if(!roomSnap.decks){
        const d = defaultDecks();
        updates['decks'] = {
          ids: {
            action: d.action.map(c=>c.id),
            life: d.life.map(c=>c.id),
            career: d.career.map(c=>c.id)
          },
          discard: {action:[], life:[], career:[]}
        };
      }
      updates['turnOrder'] = order; // use preserved + newcomers
      updates['state'] = 'playing';
      updates['currentTurnIndex'] = 0;
      updates['dice'] = null;
      updates['pendingDraw'] = null;
      updates['pendingChoice'] = null;
      updates['pendingCrisis'] = null;
      updates['turn'] = { rolled: false };
      updates['popup'] = null;
      updates['log'] = (roomSnap.log||[]).concat({ts:Date.now(), msg:'Game started!'});
      await db.ref('rooms/'+curRoom).update(updates);
    });
    byId('leaveRoomBtn').addEventListener('click', async ()=>{
      if(!curRoom) return;
      const rref = db.ref('rooms/'+curRoom);
      await rref.child('players/'+uid).set(null);
      await rref.child('turnOrder').transaction(arr => (arr||[]).filter(x => x !== uid));
      curRoom=null; roomSnap=null; show('auth');
    });

    // ===== Gameplay: ROLL =====
    byId('rollBtn').addEventListener('click', async ()=>{
      if(roomSnap.state!=='playing') return;
      const order=roomSnap.turnOrder||[]; const turnUid=order[roomSnap.currentTurnIndex||0];
      if(turnUid!==uid) return;

      const isCrisis = !!(roomSnap.pendingCrisis && roomSnap.pendingCrisis.uid===uid);

      if(isCrisis){
        diceEl.classList.add('roll');
        const roll = 1 + Math.floor(Math.random()*6);
        setTimeout(async ()=>{
          diceEl.classList.remove('roll');
          renderDie(roll);
          await db.ref(`rooms/${curRoom}`).update({ dice: roll, pendingCrisis: null });
          if(roll===1 || roll===2){ await crisisReset(); }
        }, 300);
        return;
      }

      const me = roomSnap.players?.[uid]; if((me?.skip||0)>0){
        await db.ref(`rooms/${curRoom}/players/${uid}`).update({ skip:(me.skip-1) });
        await logMsg(`${me.name} skips a turn.`);
        await nextTurn();
        return;
      }

      if((roomSnap.pendingDraw && roomSnap.pendingDraw.uid===uid) ||
         (roomSnap.pendingChoice && roomSnap.pendingChoice.uid===uid) ||
         (roomSnap.turn && roomSnap.turn.rolled)) return;

      await db.ref(`rooms/${curRoom}/turn`).set({ rolled: true });

      diceEl.classList.add('roll');
      const roll = 1 + Math.floor(Math.random()*6);

      setTimeout(async ()=>{
        diceEl.classList.remove('roll');
        renderDie(roll);
        await db.ref(`rooms/${curRoom}`).update({ dice: roll });

        const meNow = roomSnap.players?.[uid];
        const newPos = Math.min(BOARD_LEN, (meNow.pos||1)+roll);
        await db.ref(`rooms/${curRoom}/players/${uid}`).update({ pos: newPos });
        await processTile(newPos);
      }, 300);
    });

    // ===== Gameplay: STEAL (pre-roll) =====
    byId('stealBtn').addEventListener('click', async ()=>{
      const order=roomSnap.turnOrder||[]; const turnUid=order[roomSnap.currentTurnIndex||0];
      if(turnUid!==uid) return;
      const me = roomSnap.players?.[uid];
      const blocked = (roomSnap.turn?.rolled) ||
                      (roomSnap.pendingDraw && roomSnap.pendingDraw.uid===uid) ||
                      (roomSnap.pendingChoice && roomSnap.pendingChoice.uid===uid) ||
                      (roomSnap.pendingCrisis && roomSnap.pendingCrisis.uid===uid) ||
                      ((me?.skip||0)>0);
      if(blocked) return;

      stealTarget.innerHTML='';
      Object.entries(roomSnap.players||{}).forEach(([pid,p])=>{
        if(pid===uid) return;
        const opt=document.createElement('option');
        opt.value=pid; opt.textContent = `${p.name} — HP ${p.hp ?? 0} · Trauma ${p.tokens ?? 0}`;
        stealTarget.appendChild(opt);
      });
      if(!stealTarget.children.length){ alert('No valid targets.'); return; }
      stealPopup.classList.add('show');
    });

    byId('stealConfirm').addEventListener('click', async ()=>{
      const targetUid = stealTarget.value;
      if(!targetUid) return;
      stealPopup.classList.remove('show');

      await db.ref(`rooms/${curRoom}/turn`).set({ rolled: true });

      const diceEl = byId('dice');
      diceEl.classList.add('roll');
      const sRoll = 1 + Math.floor(Math.random()*6);
      setTimeout(async ()=>{
        diceEl.classList.remove('roll');
        renderDie(sRoll);

        const me = roomSnap.players[uid];
        const target = roomSnap.players[targetUid];

        if(sRoll>=5){
          const stealAmt = 100;
          await addHpTo(targetUid, -stealAmt);
          await addHp(stealAmt);
          await addTokensTo(targetUid, 1);
          await showPopupForAll({ kind:'event', title:'Steal Success', description:`${me.name} stole 100 HP from ${target.name}. ${target.name} gains +1 Trauma Token.`, player:`Steal Event` });
          await logMsg(`${me.name} steals 100 HP from ${target.name} (success). ${target.name} gets +1 Trauma Token.`);
        } else {
          await addHp(-50);
          await addTokens(1);
          await showPopupForAll({ kind:'event', title:'Steal Failed', description:`${me.name} failed the steal and loses 50 HP and gains +1 Trauma Token.`, player:`Steal Event` });
          await logMsg(`${me.name} fails the steal: -50 HP and +1 Trauma Token.`);
        }
      }, 300);
    });

    byId('endTurnBtn').addEventListener('click', async ()=>{
      if(roomSnap.state!=='playing') return;
      const order=roomSnap.turnOrder||[];
      if(order[roomSnap.currentTurnIndex||0]!==uid) return;
      if((roomSnap.pendingDraw && roomSnap.pendingDraw.uid===uid) ||
         (roomSnap.pendingChoice && roomSnap.pendingChoice.uid===uid) ||
         (roomSnap.pendingCrisis && roomSnap.pendingCrisis.uid===uid)) return;
      await nextTurn();
    });

    // Draw piles click
    byId('pile-action').addEventListener('click', ()=>handlePile('action'));
    byId('pile-life').addEventListener('click', ()=>handlePile('life'));
    byId('pile-career').addEventListener('click', ()=>handlePile('career'));
    async function handlePile(deck){
      const pending = roomSnap.pendingDraw;
      const order=roomSnap.turnOrder||[]; const myTurn = order[roomSnap.currentTurnIndex||0]===uid;
      if(!pending || !myTurn || pending.uid!==uid || pending.deck!==deck) return;
      await drawCard(deck, 1);
      const left = (pending.count||1) - 1;
      if(left>0){
        await db.ref('rooms/'+curRoom+'/pendingDraw').update({ count: left });
      } else {
        await db.ref('rooms/'+curRoom').update({ pendingDraw: null });
        await checkBurnout();
      }
    }

    // Path choice buttons (Tile 15)
    byId('collegeBtn').addEventListener('click', async ()=>{
      const pc = roomSnap.pendingChoice;
      if(!pc || pc.uid!==uid) return;
      await moveBy(5);
      await db.ref('rooms/'+curRoom).update({ pendingChoice: null });
      await processTile((roomSnap.players[uid].pos||1));
    });
    byId('streetBtn').addEventListener('click', async ()=>{
      const pc = roomSnap.pendingChoice;
      if(!pc || pc.uid!==uid) return;
      await db.ref('rooms/'+curRoom+'/pendingDraw').set({ uid, deck:'action', count:1 });
      await db.ref('rooms/'+curRoom).update({ pendingChoice: null });
      await checkBurnout();
    });

    async function logMsg(msg){
      const arr = (roomSnap.log||[]);
      arr.push({ts:Date.now(), msg});
      await db.ref('rooms/'+curRoom).update({ log: arr.slice(-300) });
    }

    // TURN ROTATION with filtering & auto-skip
    async function nextTurn(hostTriggered=false){
      const players = roomSnap.players || {};
      let order = (roomSnap.turnOrder || []).filter(id => !!players[id]);
      if(order.length === 0){
        await db.ref('rooms/' + curRoom).update({ turnOrder: [], currentTurnIndex: 0 });
        return;
      }
      let idx = roomSnap.currentTurnIndex || 0;

      for(let attempts=0; attempts<order.length; attempts++){
        idx = (idx + 1) % order.length;
        const tuid = order[idx];
        const p = players[tuid];
        if(!p) continue;
        if(p.connected === false){ continue; }
        if((p.skip||0) > 0){
          await db.ref(`rooms/${curRoom}/players/${tuid}`).update({ skip: (p.skip-1) });
          await logMsg(`${p.name} auto-skips a turn.`);
          continue;
        }
        await db.ref('rooms/' + curRoom).update({
          turnOrder: order,
          currentTurnIndex: idx,
          dice: null,
          popup: null,
          turn: { rolled: false },
          pendingDraw: null,
          pendingChoice: null,
          pendingCrisis: null
        });
        return;
      }
      await db.ref('rooms/' + curRoom).update({
        turnOrder: order,
        currentTurnIndex: idx,
        dice: null,
        popup: null,
        turn: { rolled: false },
        pendingDraw: null,
        pendingChoice: null,
        pendingCrisis: null
      });
    }

    // Unified popup setter
    async function showPopupForAll(obj){
      await db.ref('rooms/'+curRoom+'/popup').set({ ...obj, ts: Date.now() });
    }

    // ---- Tile processing ----
    async function processTile(pos, depth=0){
      if(depth>5) return;
      const meNow = roomSnap.players[uid];
      const t = (roomSnap.tiles||{})[pos]; if(!t) return;

      if(t.action==='GOTO'){
        await applyPostArgs(t.args||{});
        const dest = t.args?.tile || pos;
        await moveTo(dest);
        await processTile(dest, depth+1);
        return;
      }

      await showPopupForAll({ kind:'tile', n:t.n, title:t.title, description:t.description, player: meNow.name });
      await logMsg(`${meNow.name} lands on #${pos}: ${t.title}`);

      switch(t.action){
        case 'NONE': break;
        case 'PAYDAY': await applyPayday(t.args||{}); break;
        case 'JUMP': await moveBy(t.args?.steps||0); break;
        case 'STOP': await applyStop(t.args?.turns||1); break;
        case 'DRAW': await setPendingDraw(t.args?.deck||'action', t.args?.count||1); break;
        case 'FAMILY': await applyFamily(t.args||{}); break;
        case 'CHOOSE_CAREER': await chooseCareer(); if(t.args?.branch){ await db.ref('rooms/'+curRoom+'/pendingChoice').set({ uid }); } break;
        case 'FINISH': await finishGame(); return;
      }

      await applyPostArgs(t.args||{});
      await checkBurnout();
    }

    async function applyPostArgs(args){
      if(args.hpDelta){ await addHp(args.hpDelta); }
      if(args.tokensAdd){ await addTokens(args.tokensAdd); }
      if(args.hpIfLt){
        const me = roomSnap.players[uid]; if((me.hp||0) < args.hpIfLt.lt){ await addHp(args.hpIfLt.delta); await logMsg(`${me.name} couldn’t afford it: ${args.hpIfLt.delta} HP`); }
      }
      if(args.redeemAllTokensMultiplier){
        const me = roomSnap.players[uid];
        const tokens = me.tokens||0;
        if(tokens>0){
          const multPerToken = 0.1;
          const newHp = Math.floor((me.hp||0) * (1 + tokens*multPerToken));
          await db.ref(`rooms/${curRoom}/players/${uid}`).update({ hp:newHp, tokens:0 });
          await logMsg(`${me.name} redeems all Trauma Tokens for a multiplier → HP ${newHp}.`);
          await checkBurnout();
        }
      }
      if(args.payIfTokensGT){
        const me = roomSnap.players[uid];
        if((me.tokens||0) > args.payIfTokensGT.gt){
          await addHp(args.payIfTokensGT.amount||0);
          await logMsg(`${me.name} receives a payout: +${args.payIfTokensGT.amount||0} HP`);
        }
      }
    }

    async function setPendingDraw(deck,count){
      await db.ref('rooms/'+curRoom+'/pendingDraw').set({ uid, deck, count });
    }

    async function applyPayday(args){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      let delta = 0;
      if(args.amount) delta += args.amount;
      if(args.multiplier) delta += (meNow.hp||0) * (args.multiplier-1);
      if(args.dice) delta += (1 + Math.floor(Math.random()*6)) * (args.per||0);
      if(meNow.career?.perTurn) delta += meNow.career.perTurn;
      if(meNow.career?.dice){ delta += (1 + Math.floor(Math.random()*6)) * (meNow.career.per||20); }
      if(meNow.spouseBonusPerPayday){ delta += meNow.spouseBonusPerPayday; }
      await meRef.update({ hp: (meNow.hp||0) + delta });
      await logMsg(`${meNow.name} Payday: ${delta>=0?'+':''}${delta} HP`);
    }
    async function moveBy(steps){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const newPos = Math.max(1, Math.min(BOARD_LEN, (meNow.pos||1)+steps));
      await meRef.update({ pos: newPos });
      await logMsg(`${meNow.name} ${steps>=0?'jumps':'falls'} ${steps} to ${newPos}`);
    }
    async function moveTo(tile){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const newPos = Math.max(1, Math.min(BOARD_LEN, tile));
      await meRef.update({ pos: newPos });
    }
    async function applyStop(turns){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      const skip = Math.max(0, (meNow.skip||0) + (turns||1));
      await meRef.update({ skip });
      await logMsg(`${meNow.name} pauses for ${turns} turn(s).`);
    }

    async function drawCard(deck,count){ for(let i=0;i<count;i++) await drawOne(deck); }
    async function drawOne(deck){
      const idsRef = db.ref(`rooms/${curRoom}/decks/ids/${deck}`);
      const discRef = db.ref(`rooms/${curRoom}/decks/discard/${deck}`);
      let ids = (await idsRef.get()).val()||[];
      if(ids.length===0){
        const disc=(await discRef.get()).val()||[];
        ids = disc.slice();
        await discRef.set([]);
      }
      const cardId = ids.shift();
      await idsRef.set(ids);
      const discArr = ((roomSnap.decks?.discard?.[deck])||[]).concat(cardId);
      await discRef.set(discArr);

      const card = findCard(deck, cardId);
      const meName = roomSnap.players[uid]?.name || 'Someone';
      await showPopupForAll({ kind:'card', deck, title: card.title, description: card.text, player: meName });
      await logMsg(`${meName} draws from ${deck}: ${card.title}`);
      await applyCardEffect(card.effect||{});
    }
    function findCard(deck,id){ const d=defaultDecks(); return (d[deck]||[]).find(c=>c.id===id)||{id,title:'Unknown',text:'',effect:{}}; }

    async function applyCardEffect(effect){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      switch(effect.type){
        case 'hp': await meRef.update({ hp:(meNow.hp||0)+(effect.hp||0) }); break;
        case 'token': await meRef.update({ tokens:(meNow.tokens||0)+(effect.d||0) }); await checkBurnout(); break;
        case 'discardTokensForHp': {
          const take = Math.min(effect.max||0, meNow.tokens||0);
          const gain = (effect.per||0) * take;
          await meRef.update({ tokens:(meNow.tokens||0)-take, hp:(meNow.hp||0)+gain });
          await checkBurnout();
          break;
        }
        case 'tokenToHp': {
          if((meNow.tokens||0)>0){
            await meRef.update({ tokens:(meNow.tokens||0)-1, hp:(meNow.hp||0)+(effect.hp||0) });
            await checkBurnout();
          }
          break;
        }
        case 'career': {
          const career = { perTurn: effect.perTurn||0 };
          await meRef.update({ career });
          break;
        }
        case 'careerDice': {
          const career = { dice:true, per: effect.per||20 };
          await meRef.update({ career });
          break;
        }
      }
    }
    async function applyFamily(args){
      const meRef = db.ref(`rooms/${curRoom}/players/${uid}`);
      const meNow = roomSnap.players[uid];
      switch(args.type){
        case 'mentor': await meRef.update({ hp:(meNow.hp||0)+40 }); await logMsg('Mentor boosts +40 HP'); break;
        case 'partner': {
          const patch = {};
          if(args.spouseBonusPerPayday){ patch.spouseBonusPerPayday = args.spouseBonusPerPayday; }
          if(args.hpDelta){ patch.hp = (meNow.hp||0) + args.hpDelta; }
          await meRef.update(Object.keys(patch).length?patch:{ hp:(meNow.hp||0)+60 });
          await logMsg('Partner support locked in.');
          break;
        }
        case 'child': {
          let hp = (meNow.hp||0);
          if(args.hpDelta) hp += args.hpDelta;
          await meRef.update({ hp });
          await logMsg('Family grows; budget tightens.');
          break;
        }
        default: break;
      }
      if(args.tokensAdd){ await addTokens(args.tokensAdd); }
    }
    async function chooseCareer(){
      const meName = roomSnap.players[uid]?.name || 'Someone';
      const choices = defaultDecks().career;
      const pick = choices[Math.floor(Math.random()*choices.length)];
      await showPopupForAll({ kind:'card', deck:'career', title: pick.title, description: pick.text, player: meName });
      await applyCardEffect(pick.effect);
      await logMsg(`${meName} chooses a career: ${pick.title}`);
    }
    async function finishGame(){
      await db.ref('rooms/'+curRoom).update({ state:'finished', log:(roomSnap.log||[]).concat({ts:Date.now(), msg:'Finished! Tally scores.'}) });
    }

    // Chat
    byId('sendChatBtn').addEventListener('click', async ()=>{
      if(!curRoom) return;
      const msg = byId('chatInput').value.trim();
      if(!msg) return;
      await logMsg(`${roomSnap.players?.[uid]?.name||'Player'}: ${msg}`);
      byId('chatInput').value='';
    });

    // Back to lobby
    byId('backToLobbyBtn').addEventListener('click', async ()=>{ await db.ref('rooms/'+curRoom).update({ state:'lobby' }); });

    // ===== Create / Join =====
    async function createRoom(){
      const name = byId('playerName').value.trim();
      const avatarUrl = byId('playerAvatar').value.trim();
      if(!name){ setAuthError('Please enter a display name.'); return; }
      if(!uid){ setAuthError('Still connecting… please try again in a moment.'); return; }

      try {
        const code = codeGen();
        const tiles = defaultTiles();
        const roomRef = db.ref('rooms/'+code);
        const user = {
          name, avatarUrl: avatarUrl||'', hp: START_HP, pos: 1, tokens: 0,
          ready: false, connected: true, lastSeen: Date.now(), career: null,
          skip: 0, burnedOut: false
        };

        await roomRef.set({
          createdAt: firebase.database.ServerValue.TIMESTAMP,
          state: 'lobby',
          hostUid: uid,
          seed: Math.floor(Math.random()*1e9),
          tiles: Object.fromEntries(tiles.map(t=>[t.n,t])),
          players: { [uid]: user },
          turnOrder: [uid],
          currentTurnIndex: 0,
          dice: null,
          pendingDraw: null,
          pendingChoice: null,
          pendingCrisis: null,
          turn: { rolled: false },
          popup: null,
          log: [ {ts: Date.now(), msg: `${name} created room ${code}`} ]
        });

        curRoom = code;
        attachPresence();
        subscribeRoom();
      } catch (err){
        console.error('createRoom error:', err);
        setAuthError(err?.message || 'Failed to create room. Check Firebase rules & auth.');
      }
    }

    async function joinRoom(){
      const name = byId('playerName').value.trim();
      const avatarUrl = byId('playerAvatar').value.trim();
      const code = byId('roomCode').value.trim().toUpperCase();
      if(!name){ setAuthError('Please enter a display name.'); return; }
      if(!code){ setAuthError('Please enter a room code.'); return; }
      if(!uid){ setAuthError('Still connecting… please try again in a moment.'); return; }

      try {
        const roomRef = db.ref('rooms/'+code);
        const snap = await roomRef.get();
        if(!snap.exists()){ setAuthError('Room not found.'); return; }

        const userRef = roomRef.child('players/'+uid);
        const user = {
          name, avatarUrl: avatarUrl||'', hp: START_HP, pos: 1, tokens: 0,
          ready: false, connected: true, lastSeen: Date.now(), career: null,
          skip: 0, burnedOut: false
        };
        await userRef.update(user);
        await roomRef.child('turnOrder').transaction(arr=>{
          if(!arr) return [uid];
          if(!arr.includes(uid)) arr.push(uid);
          return arr;
        });

        curRoom = code;
        attachPresence();
        subscribeRoom();
      } catch (err){
        console.error('joinRoom error:', err);
        setAuthError(err?.message || 'Failed to join room. Check Firebase rules & auth.');
      }
    }
    byId('createRoomBtn').addEventListener('click', createRoom);
    byId('joinRoomBtn').addEventListener('click', joinRoom);

    // Auth
    auth.onAuthStateChanged(async user => {
      if(user){ uid = user.uid; show('auth'); }
      else {
        try { await auth.signInAnonymously(); }
        catch (err){ console.error('Anon auth failed:', err); setAuthError('Anonymous auth is disabled in your Firebase project. Enable it under Authentication → Sign-in method.'); }
      }
    });
  })();
</script>

<!--
  Realtime Database rules (prototype — use restrictive rules for prod):
  {
    "rules": { ".read": true, ".write": true }
  }
-->
</body>
</html>
